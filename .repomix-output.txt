This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-24T09:21:18.216Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
services/
  auth-service/
    prisma/
    src/
      controllers/
        AuthController.ts
        PermissionCheckController.ts
        PermissionController.ts
        RoleController.ts
      middleware/
        auth.ts
        rbacMiddleware.ts
      models/
        access-group.model.ts
        permission.model.ts
        Permission.ts
        role.model.ts
        Role.ts
        user.model.ts
        User.ts
      routes/
        authRoutes.ts
        permissionRoutes.ts
        roleRoutes.ts
      services/
        RbacService.ts
      types/
        express.d.ts
      config.ts
  notification-service/
    models/
      notification.model.ts
    src/
      controllers/
        NotificationController.ts
      models/
        notification.model.ts
      routes/
        notificationRoutes.ts
  order-service/
    src/
      controllers/
        OrderController.ts
      models/
        Order.ts
      routes/
        orderRoutes.ts
      services/
        WebSocketService.ts
      websocket/
        WebSocketServer.ts
      server.ts
  payment-service/
    models/
      payment.model.ts
    src/
      controllers/
        PaymentController.ts
      models/
        payment.model.ts
      routes/
        paymentRoutes.ts
  restaurant-service/
    models/
      menu.model.ts
    src/
      config/
        swagger.ts
      controllers/
        CategoryController.ts
        MenuController.ts
        ModifierController.ts
        RestaurantController.ts
        TableController.js
        TableController.ts
        VenueController.ts
        ZoneController.ts
      models/
        Category.ts
        Modifier.ts
        Restaurant.js
        Restaurant.ts
        Table.js
        Table.ts
        Venue.ts
        Zone.ts
      routes/
        category.routes.ts
        menu.routes.ts
        modifier.routes.ts
        restaurant.routes.ts
        table.routes.js
        table.routes.ts
        venue.routes.ts
        zone.routes.ts
      tests/
        restaurant.test.ts
      app.ts
    test-commands.sh
    tsconfig.json
  index.ts
src/
  config/
    websocket.ts
  controllers/
  models/
  services/
    LiveOrderMonitor.ts
  app.ts
utils/
  rabbitmq.ts
.gitignore
nodemon.json
package.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="services/auth-service/src/controllers/AuthController.ts">
import { Request, Response } from 'express';
import User, { IUser, UserRole } from '../models/user.model';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
class AuthController {
    async register(req: Request, res: Response) {
        try {
            console.log('Registration request body:', req.body);
            const { email, password, firstName, lastName, username, role = UserRole.CUSTOMER } = req.body;
            // Validate required fields
            if (!email || !password || !firstName || !lastName) {
                return res.status(400).json({ 
                    message: 'Missing required fields',
                    details: {
                        email: email ? undefined : 'Email is required',
                        password: password ? undefined : 'Password is required',
                        firstName: firstName ? undefined : 'First name is required',
                        lastName: lastName ? undefined : 'Last name is required'
                    }
                });
            }
            // Check if user already exists
            const existingUser = await User.findOne({ email });
            if (existingUser) {
                return res.status(400).json({ message: 'User already exists' });
            }
            // Create new user
            const user = new User({
                email,
                password,
                firstName,
                lastName,
                role
            });
            await user.save();
            // Generate JWT token
            const token = this.generateToken(user);
            const refreshToken = this.generateRefreshToken(user);
            res.status(201).json({
                user: {
                    id: user._id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    role: user.role
                },
                token,
                refreshToken
            });
        } catch (error) {
            console.error('Registration error:', error);
            res.status(500).json({ message: 'Error registering user' });
        }
    }
    async login(req: Request, res: Response) {
        try {
            const { email, password } = req.body;
            // Find user by email
            const user = await User.findOne({ email });
            if (!user) {
                return res.status(401).json({ message: 'Invalid credentials' });
            }
            // Check password
            const isPasswordValid = await user.comparePassword(password);
            if (!isPasswordValid) {
                return res.status(401).json({ message: 'Invalid credentials' });
            }
            // Update last login
            user.lastLogin = new Date();
            await user.save();
            // Generate JWT token
            const token = this.generateToken(user);
            const refreshToken = this.generateRefreshToken(user);
            res.status(200).json({
                user: {
                    id: user._id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    role: user.role
                },
                token,
                refreshToken
            });
        } catch (error) {
            console.error('Login error:', error);
            res.status(500).json({ message: 'Error logging in' });
        }
    }
    async refreshToken(req: Request, res: Response) {
        try {
            const { refreshToken } = req.body;
            if (!refreshToken) {
                return res.status(400).json({ message: 'Refresh token is required' });
            }
            // Verify refresh token
            const decoded = jwt.verify(
                refreshToken, 
                process.env.JWT_REFRESH_TOKEN_SECRET || 'refresh-secret'
            ) as { id: string };
            // Find user
            const user = await User.findById(decoded.id);
            if (!user) {
                return res.status(401).json({ message: 'Invalid refresh token' });
            }
            // Generate new access token
            const newAccessToken = this.generateToken(user);
            res.status(200).json({ token: newAccessToken });
        } catch (error) {
            console.error('Token refresh error:', error);
            res.status(401).json({ message: 'Invalid refresh token' });
        }
    }
    async logout(req: Request, res: Response) {
        // In a stateless JWT authentication system, the client is responsible for
        // discarding the token. The server doesn't need to do anything.
        res.status(200).json({ message: 'Logged out successfully' });
    }
    async getUserById(id: string): Promise<IUser | null> {
        try {
            return await User.findById(id);
        } catch (error) {
            console.error('Error fetching user by ID:', error);
            return null;
        }
    }
    private generateToken(user: IUser): string {
        const secret = process.env.JWT_ACCESS_TOKEN_SECRET || 'secret';
        const payload = { 
            id: user._id,
            email: user.email,
            role: user.role
        };
        const options = { 
            expiresIn: process.env.JWT_ACCESS_TOKEN_EXPIRATION_TIME || '1h' 
        };
        // @ts-ignore
        return jwt.sign(payload, secret, options);
    }
    private generateRefreshToken(user: IUser): string {
        const secret = process.env.JWT_REFRESH_TOKEN_SECRET || 'refresh-secret';
        const payload = { id: user._id };
        const options = { expiresIn: '7d' };
        // @ts-ignore
        return jwt.sign(payload, secret, options);
    }
}
export default new AuthController();
</file>

<file path="services/auth-service/src/controllers/PermissionCheckController.ts">
import { Request, Response, NextFunction } from 'express';
import { RbacService } from '../services/RbacService';
export class PermissionCheckController {
  /**
   * Handler function for routes
   */
  checkPermissionHandler = (req: Request, res: Response, next: NextFunction): void => {
    this.checkPermission(req, res).catch(next);
  };
  /**
   * Check if the current user has a specific permission
   */
  async checkPermission(req: Request, res: Response): Promise<void> {
    try {
      const { resource, action } = req.body;
      const userId = req.user?.id;
      if (!userId) {
        res.status(401).json({ 
          hasPermission: false,
          message: 'Authentication required' 
        });
        return;
      }
      if (!resource || !action) {
        res.status(400).json({ 
          hasPermission: false,
          message: 'Resource and action are required' 
        });
        return;
      }
      const rbacService = new RbacService();
      const hasPermission = await rbacService.checkPermission(userId, resource, action);
      res.status(200).json({ hasPermission });
    } catch (error) {
      console.error('Error checking permission:', error);
      res.status(500).json({ 
        hasPermission: false,
        message: 'Error checking permission' 
      });
    }
  }
}
</file>

<file path="services/auth-service/src/controllers/PermissionController.ts">
import { Request, Response } from 'express';
import { Permission, IPermission } from '../models/permission.model';
import mongoose from 'mongoose';
export class PermissionController {
  /**
   * Get all permissions
   */
  async getAllPermissions(req: Request, res: Response): Promise<void> {
    try {
      const permissions = await Permission.find();
      res.status(200).json(permissions);
    } catch (error) {
      console.error('Error fetching permissions:', error);
      res.status(500).json({ message: 'Error fetching permissions' });
    }
  }
  /**
   * Get a permission by ID
   */
  async getPermissionById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const permission = await Permission.findById(id);
      if (!permission) {
        res.status(404).json({ message: 'Permission not found' });
        return;
      }
      res.status(200).json(permission);
    } catch (error) {
      console.error('Error fetching permission:', error);
      res.status(500).json({ message: 'Error fetching permission' });
    }
  }
  /**
   * Create a new permission
   */
  async createPermission(req: Request, res: Response): Promise<void> {
    try {
      const { resource, action, description } = req.body;
      // Check if permission with the same resource and action already exists
      const existingPermission = await Permission.findOne({ resource, action });
      if (existingPermission) {
        res.status(400).json({ 
          message: `Permission for ${action} on ${resource} already exists` 
        });
        return;
      }
      const permission = new Permission({
        resource,
        action,
        description
      });
      await permission.save();
      res.status(201).json(permission);
    } catch (error) {
      console.error('Error creating permission:', error);
      res.status(500).json({ message: 'Error creating permission' });
    }
  }
  /**
   * Update a permission
   */
  async updatePermission(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { resource, action, description } = req.body;
      // Check if permission exists
      const permission = await Permission.findById(id);
      if (!permission) {
        res.status(404).json({ message: 'Permission not found' });
        return;
      }
      // Check if new resource and action conflict with existing permission
      if ((resource && resource !== permission.resource) || 
          (action && action !== permission.action)) {
        const existingPermission = await Permission.findOne({
          resource: resource || permission.resource,
          action: action || permission.action,
          _id: { $ne: id }
        });
        if (existingPermission) {
          res.status(400).json({ 
            message: `Permission for ${action || permission.action} on ${resource || permission.resource} already exists` 
          });
          return;
        }
      }
      const updatedPermission = await Permission.findByIdAndUpdate(
        id,
        { resource, action, description },
        { new: true }
      );
      res.status(200).json(updatedPermission);
    } catch (error) {
      console.error('Error updating permission:', error);
      res.status(500).json({ message: 'Error updating permission' });
    }
  }
  /**
   * Delete a permission
   */
  async deletePermission(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Check if permission exists
      const permission = await Permission.findById(id);
      if (!permission) {
        res.status(404).json({ message: 'Permission not found' });
        return;
      }
      await Permission.findByIdAndDelete(id);
      res.status(200).json({ message: 'Permission deleted successfully' });
    } catch (error) {
      console.error('Error deleting permission:', error);
      res.status(500).json({ message: 'Error deleting permission' });
    }
  }
  /**
   * Get permissions by resource
   */
  async getPermissionsByResource(req: Request, res: Response): Promise<void> {
    try {
      const { resource } = req.params;
      const permissions = await Permission.find({ resource });
      res.status(200).json(permissions);
    } catch (error) {
      console.error('Error fetching permissions by resource:', error);
      res.status(500).json({ message: 'Error fetching permissions by resource' });
    }
  }
  /**
   * Create multiple permissions at once
   */
  async createMultiplePermissions(req: Request, res: Response): Promise<void> {
    try {
      const { permissions } = req.body;
      if (!permissions || !Array.isArray(permissions) || permissions.length === 0) {
        res.status(400).json({ message: 'Permissions array is required' });
        return;
      }
      // Validate each permission
      for (const perm of permissions) {
        if (!perm.resource || !perm.action) {
          res.status(400).json({ 
            message: 'Each permission must have resource and action fields' 
          });
          return;
        }
      }
      // Check for duplicates in the request
      const resourceActionPairs = permissions.map(p => `${p.resource}:${p.action}`);
      const uniquePairs = new Set(resourceActionPairs);
      if (uniquePairs.size !== permissions.length) {
        res.status(400).json({ 
          message: 'Duplicate resource-action pairs found in the request' 
        });
        return;
      }
      // Check for existing permissions
      const existingPermissions = await Permission.find({
        $or: permissions.map(p => ({ resource: p.resource, action: p.action }))
      });
      if (existingPermissions.length > 0) {
        const existing = existingPermissions.map(
          p => `${p.resource}:${p.action}`
        ).join(', ');
        res.status(400).json({ 
          message: `The following permissions already exist: ${existing}` 
        });
        return;
      }
      // Create all permissions
      const createdPermissions = await Permission.insertMany(permissions);
      res.status(201).json(createdPermissions);
    } catch (error) {
      console.error('Error creating multiple permissions:', error);
      res.status(500).json({ message: 'Error creating multiple permissions' });
    }
  }
}
</file>

<file path="services/auth-service/src/controllers/RoleController.ts">
import { Request, Response } from 'express';
import { Role, IRole } from '../models/role.model';
import { Permission } from '../models/permission.model';
import mongoose from 'mongoose';
export class RoleController {
  /**
   * Get all roles
   */
  async getAllRoles(req: Request, res: Response): Promise<void> {
    try {
      const roles = await Role.find().populate('permissions');
      res.status(200).json(roles);
    } catch (error) {
      console.error('Error fetching roles:', error);
      res.status(500).json({ message: 'Error fetching roles' });
    }
  }
  /**
   * Get a role by ID
   */
  async getRoleById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const role = await Role.findById(id).populate('permissions');
      if (!role) {
        res.status(404).json({ message: 'Role not found' });
        return;
      }
      res.status(200).json(role);
    } catch (error) {
      console.error('Error fetching role:', error);
      res.status(500).json({ message: 'Error fetching role' });
    }
  }
  /**
   * Create a new role
   */
  async createRole(req: Request, res: Response): Promise<void> {
    try {
      const { name, description, permissions } = req.body;
      // Check if role with the same name already exists
      const existingRole = await Role.findOne({ name });
      if (existingRole) {
        res.status(400).json({ message: 'Role with this name already exists' });
        return;
      }
      // Validate permissions if provided
      if (permissions && permissions.length > 0) {
        const permissionIds = permissions.map((id: string) => 
          new mongoose.Types.ObjectId(id)
        );
        const permissionsExist = await Permission.countDocuments({
          _id: { $in: permissionIds }
        });
        if (permissionsExist !== permissions.length) {
          res.status(400).json({ message: 'One or more permissions do not exist' });
          return;
        }
      }
      const role = new Role({
        name,
        description,
        permissions: permissions || []
      });
      await role.save();
      res.status(201).json(role);
    } catch (error) {
      console.error('Error creating role:', error);
      res.status(500).json({ message: 'Error creating role' });
    }
  }
  /**
   * Update a role
   */
  async updateRole(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { name, description } = req.body;
      // Check if role exists
      const role = await Role.findById(id);
      if (!role) {
        res.status(404).json({ message: 'Role not found' });
        return;
      }
      // Check if new name conflicts with existing role
      if (name && name !== role.name) {
        const existingRole = await Role.findOne({ name });
        if (existingRole) {
          res.status(400).json({ message: 'Role with this name already exists' });
          return;
        }
      }
      const updatedRole = await Role.findByIdAndUpdate(
        id,
        { name, description },
        { new: true }
      ).populate('permissions');
      res.status(200).json(updatedRole);
    } catch (error) {
      console.error('Error updating role:', error);
      res.status(500).json({ message: 'Error updating role' });
    }
  }
  /**
   * Delete a role
   */
  async deleteRole(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Check if role exists
      const role = await Role.findById(id);
      if (!role) {
        res.status(404).json({ message: 'Role not found' });
        return;
      }
      await Role.findByIdAndDelete(id);
      res.status(200).json({ message: 'Role deleted successfully' });
    } catch (error) {
      console.error('Error deleting role:', error);
      res.status(500).json({ message: 'Error deleting role' });
    }
  }
  /**
   * Get permissions for a role
   */
  async getRolePermissions(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const role = await Role.findById(id).populate('permissions');
      if (!role) {
        res.status(404).json({ message: 'Role not found' });
        return;
      }
      res.status(200).json(role.permissions);
    } catch (error) {
      console.error('Error fetching role permissions:', error);
      res.status(500).json({ message: 'Error fetching role permissions' });
    }
  }
  /**
   * Add permissions to a role
   */
  async addPermissionsToRole(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const { permissions } = req.body;
      if (!permissions || !Array.isArray(permissions) || permissions.length === 0) {
        res.status(400).json({ message: 'Permissions array is required' });
        return;
      }
      // Check if role exists
      const role = await Role.findById(id);
      if (!role) {
        res.status(404).json({ message: 'Role not found' });
        return;
      }
      // Validate permissions
      const permissionIds = permissions.map((id: string) => 
        new mongoose.Types.ObjectId(id)
      );
      const permissionsExist = await Permission.countDocuments({
        _id: { $in: permissionIds }
      });
      if (permissionsExist !== permissions.length) {
        res.status(400).json({ message: 'One or more permissions do not exist' });
        return;
      }
      // Add permissions to role
      const updatedRole = await Role.findByIdAndUpdate(
        id,
        { $addToSet: { permissions: { $each: permissionIds } } },
        { new: true }
      ).populate('permissions');
      res.status(200).json(updatedRole);
    } catch (error) {
      console.error('Error adding permissions to role:', error);
      res.status(500).json({ message: 'Error adding permissions to role' });
    }
  }
  /**
   * Remove a permission from a role
   */
  async removePermissionFromRole(req: Request, res: Response): Promise<void> {
    try {
      const { id, permissionId } = req.params;
      // Check if role exists
      const role = await Role.findById(id);
      if (!role) {
        res.status(404).json({ message: 'Role not found' });
        return;
      }
      // Check if permission exists
      const permission = await Permission.findById(permissionId);
      if (!permission) {
        res.status(404).json({ message: 'Permission not found' });
        return;
      }
      // Remove permission from role
      const updatedRole = await Role.findByIdAndUpdate(
        id,
        { $pull: { permissions: permissionId } },
        { new: true }
      ).populate('permissions');
      res.status(200).json(updatedRole);
    } catch (error) {
      console.error('Error removing permission from role:', error);
      res.status(500).json({ message: 'Error removing permission from role' });
    }
  }
}
</file>

<file path="services/auth-service/src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { JWT_SECRET } from '../config';
// Extend Express Request type to include user property
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        role: string;
        restaurantId?: string;
      };
    }
  }
}
/**
 * Middleware to authenticate JWT tokens
 */
export const authenticateJWT = (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ message: 'Authorization header missing' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    return res.status(401).json({ message: 'Token missing' });
  }
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as {
      id: string;
      email: string;
      role: string;
      restaurantId?: string;
    };
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ message: 'Invalid or expired token' });
  }
};
</file>

<file path="services/auth-service/src/middleware/rbacMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import { RbacService } from '../services/RbacService';
/**
 * Middleware to check if a user has the required permission for a resource and action
 * @param resource The resource being accessed (e.g., 'orders', 'menu-items')
 * @param action The action being performed (e.g., 'create', 'read', 'update', 'delete')
 */
export const requirePermission = (resource: string, action: string) => {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      // Get the user ID from the request (set by auth middleware)
      const userId = req.user?.id;
      if (!userId) {
        res.status(401).json({ message: 'Authentication required' });
        return;
      }
      const rbacService = new RbacService();
      const hasPermission = await rbacService.checkPermission(userId, resource, action);
      if (!hasPermission) {
        res.status(403).json({
          message: 'Access denied. Insufficient permissions.',
          details: `Required permission: ${action} on ${resource}`
        });
        return;
      }
      next();
    } catch (error) {
      console.error('RBAC authorization error:', error);
      res.status(500).json({ message: 'Authorization error' });
    }
  };
};
/**
 * Middleware to check if a user has any of the specified roles
 * @param roles Array of role names to check against
 */
export const requireRole = (roles: string[]) => {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        res.status(401).json({ message: 'Authentication required' });
        return;
      }
      const rbacService = new RbacService();
      const hasRole = await rbacService.checkUserHasRole(userId, roles);
      if (!hasRole) {
        res.status(403).json({
          message: 'Access denied. Insufficient role.',
          details: `Required roles: ${roles.join(', ')}`
        });
        return;
      }
      next();
    } catch (error) {
      console.error('RBAC role check error:', error);
      res.status(500).json({ message: 'Authorization error' });
    }
  };
};
</file>

<file path="services/auth-service/src/models/access-group.model.ts">
import mongoose, { Document, Schema } from 'mongoose';
import { IPermission } from './permission.model';
export interface IAccessGroup extends Document {
  name: string;
  description: string;
  permissions: IPermission[] | string[];
  createdAt: Date;
  updatedAt: Date;
}
const AccessGroupSchema = new Schema<IAccessGroup>(
  {
    name: {
      type: String,
      required: true,
      unique: true,
      trim: true
    },
    description: {
      type: String,
      required: false
    },
    permissions: [{
      type: Schema.Types.ObjectId,
      ref: 'Permission'
    }]
  },
  {
    timestamps: true
  }
);
// Create a compound index for efficient querying
AccessGroupSchema.index({ name: 1 });
export const AccessGroup = mongoose.model<IAccessGroup>('AccessGroup', AccessGroupSchema);
</file>

<file path="services/auth-service/src/models/permission.model.ts">
import mongoose, { Document, Schema } from 'mongoose';
export interface IPermission extends Document {
  resource: string;
  action: string;
  description: string;
  createdAt: Date;
  updatedAt: Date;
}
const PermissionSchema = new Schema<IPermission>(
  {
    resource: {
      type: String,
      required: true,
      trim: true
    },
    action: {
      type: String,
      required: true,
      trim: true
    },
    description: {
      type: String,
      required: false
    }
  },
  {
    timestamps: true
  }
);
// Create a compound index for efficient querying and to ensure uniqueness
PermissionSchema.index({ resource: 1, action: 1 }, { unique: true });
export const Permission = mongoose.model<IPermission>('Permission', PermissionSchema);
</file>

<file path="services/auth-service/src/models/Permission.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IPermission extends Document {
  resource: string;
  action: string;
  description: string;
}
const PermissionSchema = new Schema<IPermission>({
  resource: { type: String, required: true },
  action: { type: String, required: true },
  description: { type: String, required: true }
});
// Compound index to ensure unique resource-action pairs
PermissionSchema.index({ resource: 1, action: 1 }, { unique: true });
export const Permission = mongoose.model<IPermission>('Permission', PermissionSchema);
</file>

<file path="services/auth-service/src/models/role.model.ts">
import mongoose, { Document, Schema } from 'mongoose';
import { Permission, IPermission } from './permission.model';
export interface IRole extends Document {
  name: string;
  description: string;
  permissions: IPermission[] | string[];
  createdAt: Date;
  updatedAt: Date;
}
const RoleSchema = new Schema<IRole>(
  {
    name: {
      type: String,
      required: true,
      unique: true,
      trim: true
    },
    description: {
      type: String,
      required: false
    },
    permissions: [{
      type: Schema.Types.ObjectId,
      ref: 'Permission'
    }]
  },
  {
    timestamps: true
  }
);
// Create a compound index for efficient querying
RoleSchema.index({ name: 1 });
export const Role = mongoose.model<IRole>('Role', RoleSchema);
</file>

<file path="services/auth-service/src/models/Role.ts">
import mongoose, { Schema, Document, Types } from 'mongoose';
import { IPermission } from './Permission';
export interface IRole extends Document {
  name: string;
  description: string;
  permissions: Types.ObjectId[] | IPermission[];
}
const RoleSchema = new Schema<IRole>({
  name: { type: String, required: true, unique: true },
  description: { type: String, required: true },
  permissions: [{ type: Schema.Types.ObjectId, ref: 'Permission' }]
});
export const Role = mongoose.model<IRole>('Role', RoleSchema);
</file>

<file path="services/auth-service/src/models/user.model.ts">
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcrypt';
import { IRole } from './role.model';
import { IPermission } from './permission.model';
export enum UserRole {
  CUSTOMER = 'customer',
  RESTAURANT_ADMIN = 'restaurant_admin',
  SYSTEM_ADMIN = 'system_admin'
}
export interface IUser extends Document {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  role: UserRole;
  // RBAC fields
  roles: IRole[] | string[];
  directPermissions: IPermission[] | string[];
  restaurantId?: mongoose.Types.ObjectId;
  phoneNumber?: string;
  isActive: boolean;
  lastLogin?: Date;
  createdAt: Date;
  updatedAt: Date;
  isRestaurantAdmin(): boolean;
  comparePassword(candidatePassword: string): Promise<boolean>;
}
const UserSchema: Schema = new Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true
  },
  firstName: {
    type: String,
    required: true,
    trim: true
  },
  lastName: {
    type: String,
    required: true,
    trim: true
  },
  role: {
    type: String,
    enum: Object.values(UserRole),
    default: UserRole.CUSTOMER
  },
  // RBAC fields
  roles: [{
    type: Schema.Types.ObjectId,
    ref: 'Role'
  }],
  directPermissions: [{
    type: Schema.Types.ObjectId,
    ref: 'Permission'
  }],
  restaurantId: {
    type: Schema.Types.ObjectId,
    ref: 'Restaurant'
  },
  phoneNumber: {
    type: String,
    trim: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastLogin: {
    type: Date
  }
}, {
  timestamps: true
});
// Add methods
UserSchema.methods.isRestaurantAdmin = function(this: IUser): boolean {
  return this.role === UserRole.RESTAURANT_ADMIN;
};
UserSchema.methods.comparePassword = async function(this: IUser, candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};
// Middleware to hash password before saving
UserSchema.pre('save', async function(this: IUser, next) {
  if (!this.isModified('password')) {
    return next();
  }
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});
export default mongoose.model<IUser>('User', UserSchema);
</file>

<file path="services/auth-service/src/models/User.ts">
import mongoose, { Document, Schema } from 'mongoose';
import bcrypt from 'bcrypt';
interface IUser extends Document {
  email: string;
  password: string;
  roles: mongoose.Types.ObjectId[];
  permissions: mongoose.Types.ObjectId[];
  comparePassword(candidatePassword: string): Promise<boolean>;
  createdAt: Date;
  updatedAt: Date;
}
const UserSchema = new Schema<IUser>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true
    },
    password: {
      type: String,
      required: true
    },
    roles: [{
      type: Schema.Types.ObjectId,
      ref: 'Role'
    }],
    permissions: [{
      type: Schema.Types.ObjectId,
      ref: 'Permission'
    }]
  },
  {
    timestamps: true
  }
);
// Hash password before saving
UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as Error);
  }
});
// Method to compare password
UserSchema.methods.comparePassword = async function(candidatePassword: string): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};
// Create a compound index for efficient querying
UserSchema.index({ email: 1 });
// Check if the model exists before creating it
const User = mongoose.models.User || mongoose.model<IUser>('User', UserSchema);
export { User };
export type { IUser };
</file>

<file path="services/auth-service/src/routes/authRoutes.ts">
import express from 'express';
import AuthController from '../controllers/AuthController';
import { requirePermission } from '../middleware/rbacMiddleware';
import { RbacService } from '../services/RbacService';
const router = express.Router();
const rbacService = new RbacService();
// Authentication routes
router.post('/register', async (req, res): Promise<void> => {
  await AuthController.register(req, res);
});
router.post('/login', async (req, res): Promise<void> => {
  await AuthController.login(req, res);
});
router.post('/refresh-token', async (req, res): Promise<void> => {
  await AuthController.refreshToken(req, res);
});
router.post('/logout', async (req, res): Promise<void> => {
  await AuthController.logout(req, res);
});
// User-Role management routes
router.get(
  '/users/:id/roles',
  requirePermission('users', 'read'),
  async (req, res): Promise<void> => {
    try {
      const user = await AuthController.getUserById(req.params.id);
      if (!user) {
        res.status(404).json({ message: 'User not found' });
        return;
      }
      // Populate roles
      await user.populate('roles');
      res.status(200).json(user.roles);
    } catch (error) {
      console.error('Error fetching user roles:', error);
      res.status(500).json({ message: 'Error fetching user roles' });
    }
  }
);
router.post(
  '/users/:id/roles',
  requirePermission('users', 'update'),
  async (req, res): Promise<void> => {
    try {
      const { roleId } = req.body;
      if (!roleId) {
        res.status(400).json({ message: 'Role ID is required' });
        return;
      }
      const success = await rbacService.assignRoleToUser(req.params.id, roleId);
      if (!success) {
        res.status(404).json({ message: 'User or role not found' });
        return;
      }
      res.status(200).json({ message: 'Role assigned successfully' });
    } catch (error) {
      console.error('Error assigning role to user:', error);
      res.status(500).json({ message: 'Error assigning role to user' });
    }
  }
);
router.delete(
  '/users/:id/roles/:roleId',
  requirePermission('users', 'update'),
  async (req, res): Promise<void> => {
    try {
      const success = await rbacService.removeRoleFromUser(req.params.id, req.params.roleId);
      if (!success) {
        res.status(404).json({ message: 'User or role not found' });
        return;
      }
      res.status(200).json({ message: 'Role removed successfully' });
    } catch (error) {
      console.error('Error removing role from user:', error);
      res.status(500).json({ message: 'Error removing role from user' });
    }
  }
);
// User-Permission management routes
router.get(
  '/users/:id/permissions',
  requirePermission('users', 'read'),
  async (req, res): Promise<void> => {
    try {
      const permissions = await rbacService.getUserPermissions(req.params.id);
      res.status(200).json(permissions);
    } catch (error) {
      console.error('Error fetching user permissions:', error);
      res.status(500).json({ message: 'Error fetching user permissions' });
    }
  }
);
router.post(
  '/users/:id/permissions',
  requirePermission('users', 'update'),
  async (req, res): Promise<void> => {
    try {
      const { permissionId } = req.body;
      if (!permissionId) {
        res.status(400).json({ message: 'Permission ID is required' });
        return;
      }
      const success = await rbacService.assignPermissionToUser(req.params.id, permissionId);
      if (!success) {
        res.status(404).json({ message: 'User or permission not found' });
        return;
      }
      res.status(200).json({ message: 'Permission assigned successfully' });
    } catch (error) {
      console.error('Error assigning permission to user:', error);
      res.status(500).json({ message: 'Error assigning permission to user' });
    }
  }
);
router.delete(
  '/users/:id/permissions/:permissionId',
  requirePermission('users', 'update'),
  async (req, res): Promise<void> => {
    try {
      const success = await rbacService.removePermissionFromUser(req.params.id, req.params.permissionId);
      if (!success) {
        res.status(404).json({ message: 'User or permission not found' });
        return;
      }
      res.status(200).json({ message: 'Permission removed successfully' });
    } catch (error) {
      console.error('Error removing permission from user:', error);
      res.status(500).json({ message: 'Error removing permission from user' });
    }
  }
);
export default router;
</file>

<file path="services/auth-service/src/routes/permissionRoutes.ts">
import express, { Request, Response, NextFunction } from 'express';
import { PermissionController } from '../controllers/PermissionController';
import { requirePermission } from '../middleware/rbacMiddleware';
import { PermissionCheckController } from '../controllers/PermissionCheckController';
import { authenticateJWT } from '../middleware/auth';
const router = express.Router();
const permissionController = new PermissionController();
const permissionCheckController = new PermissionCheckController();
// Get all permissions
router.get(
  '/',
  requirePermission('permissions', 'read'),
  permissionController.getAllPermissions
);
// Get a permission by ID
router.get(
  '/:id',
  requirePermission('permissions', 'read'),
  permissionController.getPermissionById
);
// Create a new permission
router.post(
  '/',
  requirePermission('permissions', 'create'),
  permissionController.createPermission
);
// Update a permission
router.patch(
  '/:id',
  requirePermission('permissions', 'update'),
  permissionController.updatePermission
);
// Delete a permission
router.delete(
  '/:id',
  requirePermission('permissions', 'delete'),
  permissionController.deletePermission
);
// Get permissions by resource
router.get(
  '/resource/:resource',
  requirePermission('permissions', 'read'),
  permissionController.getPermissionsByResource
);
// Create multiple permissions at once
router.post(
  '/batch',
  requirePermission('permissions', 'create'),
  permissionController.createMultiplePermissions
);
// Route to check if a user has a specific permission (using @ts-ignore to bypass type check issues)
// @ts-ignore - Express route handler type issues
router.post('/check', authenticateJWT, async (req: Request, res: Response, next: NextFunction) => {
  try {
    await permissionCheckController.checkPermission(req, res);
  } catch (error) {
    next(error);
  }
});
export default router;
</file>

<file path="services/auth-service/src/routes/roleRoutes.ts">
import express from 'express';
import { RoleController } from '../controllers/RoleController';
import { requirePermission } from '../middleware/rbacMiddleware';
const router = express.Router();
const roleController = new RoleController();
// Get all roles
router.get(
  '/',
  requirePermission('roles', 'read'),
  roleController.getAllRoles
);
// Get a role by ID
router.get(
  '/:id',
  requirePermission('roles', 'read'),
  roleController.getRoleById
);
// Create a new role
router.post(
  '/',
  requirePermission('roles', 'create'),
  roleController.createRole
);
// Update a role
router.patch(
  '/:id',
  requirePermission('roles', 'update'),
  roleController.updateRole
);
// Delete a role
router.delete(
  '/:id',
  requirePermission('roles', 'delete'),
  roleController.deleteRole
);
// Get permissions for a role
router.get(
  '/:id/permissions',
  requirePermission('roles', 'read'),
  roleController.getRolePermissions
);
// Add permissions to a role
router.post(
  '/:id/permissions',
  requirePermission('roles', 'update'),
  roleController.addPermissionsToRole
);
// Remove a permission from a role
router.delete(
  '/:id/permissions/:permissionId',
  requirePermission('roles', 'update'),
  roleController.removePermissionFromRole
);
export default router;
</file>

<file path="services/auth-service/src/services/RbacService.ts">
import User from '../models/user.model';
import { Role, IRole } from '../models/role.model';
import { Permission, IPermission } from '../models/permission.model';
import mongoose from 'mongoose';
export class RbacService {
  /**
   * Check if a user has a specific permission for a resource and action
   */
  async checkPermission(userId: string, resource: string, action: string): Promise<boolean> {
    try {
      // Find the user and populate roles and direct permissions
      const user = await User.findById(userId)
        .populate({
          path: 'roles',
          populate: {
            path: 'permissions'
          }
        })
        .populate('directPermissions');
      if (!user) {
        return false;
      }
      // Check direct permissions first
      if (user.directPermissions && Array.isArray(user.directPermissions)) {
        const hasDirectPermission = user.directPermissions.some((permission: any) =>
          permission.resource === resource && permission.action === action
        );
        if (hasDirectPermission) {
          return true;
        }
      }
      // Check permissions from roles
      if (user.roles && Array.isArray(user.roles)) {
        for (const role of user.roles) {
          // Skip if role is just a string ID
          if (typeof role === 'string') continue;
          const roleObj = role as IRole;
          if (roleObj.permissions && Array.isArray(roleObj.permissions)) {
            const hasPermissionFromRole = roleObj.permissions.some((permission: any) =>
              permission.resource === resource && permission.action === action
            );
            if (hasPermissionFromRole) {
              return true;
            }
          }
        }
      }
      return false;
    } catch (error) {
      console.error('Error checking permission:', error);
      return false;
    }
  }
  /**
   * Check if a user has any of the specified roles
   */
  async checkUserHasRole(userId: string, roleNames: string[]): Promise<boolean> {
    try {
      const user = await User.findById(userId).populate('roles');
      if (!user || !user.roles || !Array.isArray(user.roles)) {
        return false;
      }
      return user.roles.some((role: any) => {
        if (typeof role === 'string') return false;
        return roleNames.includes((role as IRole).name);
      });
    } catch (error) {
      console.error('Error checking user roles:', error);
      return false;
    }
  }
  /**
   * Assign a role to a user
   */
  async assignRoleToUser(userId: string, roleId: string): Promise<boolean> {
    try {
      // Check if user and role exist
      const user = await User.findById(userId);
      const role = await Role.findById(roleId);
      if (!user || !role) {
        return false;
      }
      // Add role to user if not already assigned
      await User.findByIdAndUpdate(
        userId,
        { $addToSet: { roles: roleId } },
        { new: true }
      );
      return true;
    } catch (error) {
      console.error('Error assigning role to user:', error);
      return false;
    }
  }
  /**
   * Remove a role from a user
   */
  async removeRoleFromUser(userId: string, roleId: string): Promise<boolean> {
    try {
      // Check if user and role exist
      const user = await User.findById(userId);
      const role = await Role.findById(roleId);
      if (!user || !role) {
        return false;
      }
      // Remove role from user
      await User.findByIdAndUpdate(
        userId,
        { $pull: { roles: roleId } },
        { new: true }
      );
      return true;
    } catch (error) {
      console.error('Error removing role from user:', error);
      return false;
    }
  }
  /**
   * Get all permissions for a user (from roles and direct permissions)
   */
  async getUserPermissions(userId: string): Promise<any[]> {
    try {
      const user = await User.findById(userId)
        .populate({
          path: 'roles',
          populate: {
            path: 'permissions'
          }
        })
        .populate('directPermissions');
      if (!user) {
        return [];
      }
      const permissions = new Set();
      // Add direct permissions
      if (user.directPermissions && Array.isArray(user.directPermissions)) {
        user.directPermissions.forEach((permission: any) => {
          permissions.add(JSON.stringify(permission));
        });
      }
      // Add permissions from roles
      if (user.roles && Array.isArray(user.roles)) {
        for (const role of user.roles) {
          // Skip if role is just a string ID
          if (typeof role === 'string') continue;
          const roleObj = role as IRole;
          if (roleObj.permissions && Array.isArray(roleObj.permissions)) {
            roleObj.permissions.forEach((permission: any) => {
              permissions.add(JSON.stringify(permission));
            });
          }
        }
      }
      // Convert back to objects
      return Array.from(permissions).map(p => JSON.parse(p as string));
    } catch (error) {
      console.error('Error getting user permissions:', error);
      return [];
    }
  }
  /**
   * Assign a direct permission to a user
   */
  async assignPermissionToUser(userId: string, permissionId: string): Promise<boolean> {
    try {
      // Check if user and permission exist
      const user = await User.findById(userId);
      const permission = await Permission.findById(permissionId);
      if (!user || !permission) {
        return false;
      }
      // Add permission to user if not already assigned
      await User.findByIdAndUpdate(
        userId,
        { $addToSet: { directPermissions: permissionId } },
        { new: true }
      );
      return true;
    } catch (error) {
      console.error('Error assigning permission to user:', error);
      return false;
    }
  }
  /**
   * Remove a direct permission from a user
   */
  async removePermissionFromUser(userId: string, permissionId: string): Promise<boolean> {
    try {
      // Check if user and permission exist
      const user = await User.findById(userId);
      const permission = await Permission.findById(permissionId);
      if (!user || !permission) {
        return false;
      }
      // Remove permission from user
      await User.findByIdAndUpdate(
        userId,
        { $pull: { directPermissions: permissionId } },
        { new: true }
      );
      return true;
    } catch (error) {
      console.error('Error removing permission from user:', error);
      return false;
    }
  }
}
</file>

<file path="services/auth-service/src/types/express.d.ts">
import { IUser } from '../models/user.model';
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        role: string;
        restaurantId?: string;
      };
    }
  }
}
</file>

<file path="services/auth-service/src/config.ts">
// Environment variables
export const PORT = process.env.PORT || 3001;
export const NODE_ENV = process.env.NODE_ENV || 'development';
export const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret_key';
export const JWT_EXPIRY = process.env.JWT_EXPIRY || '1h';
export const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET || 'your_refresh_token_secret';
export const REFRESH_TOKEN_EXPIRY = process.env.REFRESH_TOKEN_EXPIRY || '7d';
// Database configuration
export const DB_HOST = process.env.DB_HOST || 'localhost';
export const DB_PORT = process.env.DB_PORT || '5432';
export const DB_NAME = process.env.DB_NAME || 'inseat_auth';
export const DB_USER = process.env.DB_USER || 'postgres';
export const DB_PASSWORD = process.env.DB_PASSWORD || 'postgres';
// CORS configuration
export const CORS_ORIGIN = process.env.CORS_ORIGIN || '*';
// API configuration
export const API_PREFIX = process.env.API_PREFIX || '/api/v1';
</file>

<file path="services/notification-service/models/notification.model.ts">
import { Schema, model } from 'mongoose';
interface INotification {
    userId: string;
    message: string;
    timestamp: Date;
}
const notificationSchema = new Schema<INotification>({
    userId: { type: String, required: true },
    message: { type: String, required: true },
    timestamp: { type: Date, default: Date.now }
});
const Notification = model<INotification>('Notification', notificationSchema);
export default Notification;
</file>

<file path="services/notification-service/src/controllers/NotificationController.ts">
import { Request, Response } from 'express';
import Notification from '../models/notification.model';
class NotificationController {
    async createNotification(req: Request, res: Response) {
        // Create notification logic
    }
    async getNotifications(req: Request, res: Response) {
        // Get notifications logic
    }
}
export default new NotificationController();
</file>

<file path="services/notification-service/src/models/notification.model.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface INotification extends Document {
  userId: mongoose.Types.ObjectId;
  type: string;
  title: string;
  message: string;
  read: boolean;
  createdAt: Date;
  metadata?: Record<string, any>;
}
const NotificationSchema: Schema = new Schema({
  userId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'User'
  },
  type: {
    type: String,
    required: true
  },
  title: {
    type: String,
    required: true
  },
  message: {
    type: String,
    required: true
  },
  read: {
    type: Boolean,
    default: false
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  metadata: {
    type: Schema.Types.Mixed
  }
});
export default mongoose.model<INotification>('Notification', NotificationSchema);
</file>

<file path="services/notification-service/src/routes/notificationRoutes.ts">
import { Router } from 'express';
import NotificationController from '../controllers/NotificationController';
const router = Router();
router.post('/', NotificationController.createNotification);
router.get('/', NotificationController.getNotifications);
export default router;
</file>

<file path="services/order-service/src/controllers/OrderController.ts">
import { Request, Response } from 'express';
import Order, { IOrder } from '../models/Order';
import { WebSocketService } from '../services/WebSocketService';
export class OrderController {
  private wsService?: WebSocketService;
  constructor(wsService?: WebSocketService) {
    this.wsService = wsService;
  }
  // Create a new order
  public async create(req: Request, res: Response): Promise<void> {
    try {
      const orderData = req.body;
      // Calculate total amount
      orderData.totalAmount = orderData.items.reduce((total: number, item: any) => {
        const modifiersTotal = item.modifiers.reduce((modTotal: number, mod: any) => modTotal + mod.price, 0);
        return total + (item.quantity * (item.price + modifiersTotal));
      }, 0);
      const order = new Order(orderData);
      const savedOrder = await order.save();
      // Notify connected clients about the new order
      if (this.wsService) {
        this.wsService.notifyNewOrder(savedOrder);
      }
      res.status(201).json(savedOrder);
    } catch (error) {
      res.status(500).json({ error: 'Error creating order' });
    }
  }
  // Get all orders
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId } = req.query;
      const query = restaurantId ? { restaurantId } : {};
      const orders = await Order.find(query);
      res.status(200).json(orders);
    } catch (error) {
      res.status(500).json({ error: 'Error fetching orders' });
    }
  }
  // Get order by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const order = await Order.findById(req.params.id);
      if (!order) {
        res.status(404).json({ error: 'Order not found' });
        return;
      }
      res.status(200).json(order);
    } catch (error) {
      res.status(500).json({ error: 'Error fetching order' });
    }
  }
  // Update order status
  public async updateStatus(req: Request, res: Response): Promise<void> {
    try {
      const { status } = req.body;
      const order = await Order.findByIdAndUpdate(
        req.params.id,
        { status },
        { new: true }
      );
      if (!order) {
        res.status(404).json({ error: 'Order not found' });
        return;
      }
      // Notify connected clients about the order update
      if (this.wsService) {
        this.wsService.notifyOrderUpdate(order);
      }
      res.status(200).json(order);
    } catch (error) {
      res.status(500).json({ error: 'Error updating order status' });
    }
  }
  // Update payment status
  public async updatePaymentStatus(req: Request, res: Response): Promise<void> {
    try {
      const { paymentStatus } = req.body;
      const order = await Order.findByIdAndUpdate(
        req.params.id,
        { paymentStatus },
        { new: true }
      );
      if (!order) {
        res.status(404).json({ error: 'Order not found' });
        return;
      }
      // Notify connected clients about the order update
      if (this.wsService) {
        this.wsService.notifyOrderUpdate(order);
      }
      res.status(200).json(order);
    } catch (error) {
      res.status(500).json({ error: 'Error updating payment status' });
    }
  }
  // Cancel order
  public async cancel(req: Request, res: Response): Promise<void> {
    try {
      const order = await Order.findByIdAndUpdate(
        req.params.id,
        { status: 'cancelled' },
        { new: true }
      );
      if (!order) {
        res.status(404).json({ error: 'Order not found' });
        return;
      }
      // Notify connected clients about the order cancellation
      if (this.wsService) {
        this.wsService.notifyOrderCancellation(order);
      }
      res.status(200).json(order);
    } catch (error) {
      res.status(500).json({ error: 'Error cancelling order' });
    }
  }
  // Get orders by table
  public async getByTable(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableNumber } = req.params;
      const orders = await Order.find({
        restaurantId,
        tableNumber,
        status: { $nin: ['delivered', 'cancelled'] }
      });
      res.status(200).json(orders);
    } catch (error) {
      res.status(500).json({ error: 'Error fetching orders by table' });
    }
  }
}
</file>

<file path="services/order-service/src/models/Order.ts">
import mongoose, { Schema, Document } from 'mongoose';
export enum OrderStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  IN_PREPARATION = 'IN_PREPARATION',
  READY = 'READY',
  DELIVERED = 'DELIVERED',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED'
}
export enum PaymentStatus {
  PENDING = 'PENDING',
  PROCESSING = 'PROCESSING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  REFUNDED = 'REFUNDED'
}
export interface IOrderItem extends Document {
  menuItem: mongoose.Types.ObjectId;
  quantity: number;
  price: number;
  modifiers: {
    groupId: mongoose.Types.ObjectId;
    selections: {
      optionId: mongoose.Types.ObjectId;
      quantity: number;
      price: number;
    }[];
  }[];
  specialInstructions?: string;
  subtotal: number;
}
export interface IOrder extends Document {
  orderNumber: string;
  restaurantId: mongoose.Types.ObjectId;
  tableId: mongoose.Types.ObjectId;
  userId: mongoose.Types.ObjectId;
  items: IOrderItem[];
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  subtotal: number;
  tax: number;
  tip?: number;
  total: number;
  specialInstructions?: string;
  estimatedPreparationTime?: number;
  orderType: 'DINE_IN' | 'TAKEAWAY';
  createdAt: Date;
  updatedAt: Date;
}
const OrderItemSchema: Schema = new Schema({
  menuItem: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'MenuItem',
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: 1
  },
  price: {
    type: Number,
    required: true,
    min: 0
  },
  modifiers: [{
    groupId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'ModifierGroup'
    },
    selections: [{
      optionId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'ModifierOption'
      },
      quantity: {
        type: Number,
        required: true,
        min: 1
      },
      price: {
        type: Number,
        required: true,
        min: 0
      }
    }]
  }],
  specialInstructions: {
    type: String,
    trim: true
  },
  subtotal: {
    type: Number,
    required: true,
    min: 0
  }
});
const OrderSchema: Schema = new Schema({
  orderNumber: {
    type: String,
    required: true,
    unique: true
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Restaurant',
    required: true
  },
  tableId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Table',
    required: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  items: [OrderItemSchema],
  status: {
    type: String,
    enum: Object.values(OrderStatus),
    default: OrderStatus.PENDING
  },
  paymentStatus: {
    type: String,
    enum: Object.values(PaymentStatus),
    default: PaymentStatus.PENDING
  },
  subtotal: {
    type: Number,
    required: true,
    min: 0
  },
  tax: {
    type: Number,
    required: true,
    min: 0
  },
  tip: {
    type: Number,
    min: 0
  },
  total: {
    type: Number,
    required: true,
    min: 0
  },
  specialInstructions: {
    type: String,
    trim: true
  },
  estimatedPreparationTime: {
    type: Number,
    min: 0
  },
  orderType: {
    type: String,
    enum: ['DINE_IN', 'TAKEAWAY'],
    required: true
  }
}, {
  timestamps: true
});
// Generate order number before saving
OrderSchema.pre('save', async function(next) {
  if (this.isNew) {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const random = Math.floor(Math.random() * 9999).toString().padStart(4, '0');
    this.orderNumber = `${year}${month}${day}-${random}`;
  }
  next();
});
export default mongoose.model<IOrder>('Order', OrderSchema);
</file>

<file path="services/order-service/src/routes/orderRoutes.ts">
import { Router } from 'express';
import { OrderController } from '../controllers/OrderController';
import { WebSocketService } from '../services/WebSocketService';
export const createOrderRoutes = (wsService?: WebSocketService) => {
  const router = Router();
  const controller = new OrderController(wsService);
  // Order CRUD routes
  router.post('/orders', controller.create.bind(controller));
  router.get('/orders', controller.getAll.bind(controller));
  router.get('/orders/:id', controller.getById.bind(controller));
  router.put('/orders/:id/status', controller.updateStatus.bind(controller));
  router.put('/orders/:id/payment', controller.updatePaymentStatus.bind(controller));
  router.post('/orders/:id/cancel', controller.cancel.bind(controller));
  // Table specific routes
  router.get('/restaurants/:restaurantId/tables/:tableNumber/orders', controller.getByTable.bind(controller));
  return router;
};
export default createOrderRoutes();
</file>

<file path="services/order-service/src/services/WebSocketService.ts">
import WebSocket from 'ws';
import { IOrder } from '../models/Order';
export class WebSocketService {
  private wss: WebSocket.Server;
  constructor(wss: WebSocket.Server) {
    this.wss = wss;
  }
  /**
   * Broadcast a message to all connected clients
   */
  broadcast(message: any): void {
    this.wss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }
  /**
   * Notify all clients about a new order
   */
  notifyNewOrder(order: IOrder): void {
    this.broadcast({ 
      type: 'NEW_ORDER', 
      data: order 
    });
    console.log(`WebSocket: Notified clients about new order ${order.orderNumber}`);
  }
  /**
   * Notify all clients about an order update
   */
  notifyOrderUpdate(order: IOrder): void {
    this.broadcast({ 
      type: 'ORDER_UPDATE', 
      data: order 
    });
    console.log(`WebSocket: Notified clients about order update ${order.orderNumber}`);
  }
  /**
   * Notify all clients about an order cancellation
   */
  notifyOrderCancellation(order: IOrder): void {
    this.broadcast({ 
      type: 'ORDER_CANCELLED', 
      data: order 
    });
  }
}
</file>

<file path="services/order-service/src/websocket/WebSocketServer.ts">
import WebSocket from 'ws';
import http from 'http';
import { WebSocketService } from '../services/WebSocketService';
/**
 * Initialize the WebSocket server
 * @param server HTTP server instance
 * @returns WebSocketService instance
 */
export const initializeWebSocketServer = (server: http.Server): WebSocketService => {
  const wss = new WebSocket.Server({ server });
  const wsService = new WebSocketService(wss);
  wss.on('connection', (ws: WebSocket) => {
    console.log('WebSocket: Client connected');
    // Send initial connection message
    ws.send(JSON.stringify({ 
      type: 'CONNECTION_ESTABLISHED', 
      message: 'Connected to INSEAT order service' 
    }));
    // Handle client messages
    ws.on('message', (message: string) => {
      try {
        const parsedMessage = JSON.parse(message.toString());
        console.log('WebSocket: Received message:', parsedMessage);
        // Handle ping messages to keep connection alive
        if (parsedMessage.type === 'PING') {
          ws.send(JSON.stringify({ type: 'PONG', timestamp: Date.now() }));
        }
      } catch (error) {
        console.error('WebSocket: Error parsing message:', error);
      }
    });
    ws.on('close', () => {
      console.log('WebSocket: Client disconnected');
    });
    ws.on('error', (error) => {
      console.error('WebSocket: Client error:', error);
    });
  });
  return wsService;
};
</file>

<file path="services/order-service/src/server.ts">
import express from 'express';
import http from 'http';
import cors from 'cors';
import mongoose from 'mongoose';
import { createOrderRoutes } from './routes/orderRoutes';
import { initializeWebSocketServer } from './websocket/WebSocketServer';
import { OrderController } from './controllers/OrderController';
// Create Express app
const app = express();
// Middleware
app.use(cors());
app.use(express.json());
// Create HTTP server
const server = http.createServer(app);
// Initialize WebSocket server
const wsService = initializeWebSocketServer(server);
// Set up routes with WebSocket service
const orderRouter = createOrderRoutes(wsService);
app.use('/api', orderRouter);
// Database connection
const connectDB = async () => {
  try {
    await mongoose.connect('mongodb://localhost:27017/inseat', {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    } as any);
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};
// Start server
const PORT = process.env.PORT || 5000;
connectDB().then(() => {
  server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
    console.log(`WebSocket server initialized`);
  });
});
export { server, app, wsService };
</file>

<file path="services/payment-service/models/payment.model.ts">
import { Schema, model } from 'mongoose';
interface IPayment {
    userId: string;
    amount: number;
    status: string;
}
const paymentSchema = new Schema<IPayment>({
    userId: { type: String, required: true },
    amount: { type: Number, required: true },
    status: { type: String, required: true }
});
const Payment = model<IPayment>('Payment', paymentSchema);
export default Payment;
</file>

<file path="services/payment-service/src/controllers/PaymentController.ts">
import { Request, Response } from 'express';
import Payment from '../models/payment.model';
class PaymentController {
    async processPayment(req: Request, res: Response) {
        // Payment processing logic
    }
    async getPaymentStatus(req: Request, res: Response) {
        // Get payment status logic
    }
}
export default new PaymentController();
</file>

<file path="services/payment-service/src/models/payment.model.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IPayment extends Document {
  orderId: mongoose.Types.ObjectId;
  amount: number;
  currency: string;
  status: string;
  paymentMethod: string;
  transactionId?: string;
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}
const PaymentSchema: Schema = new Schema({
  orderId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Order'
  },
  amount: {
    type: Number,
    required: true
  },
  currency: {
    type: String,
    required: true,
    default: 'USD'
  },
  status: {
    type: String,
    required: true,
    enum: ['pending', 'completed', 'failed', 'refunded'],
    default: 'pending'
  },
  paymentMethod: {
    type: String,
    required: true
  },
  transactionId: {
    type: String
  },
  metadata: {
    type: Schema.Types.Mixed
  }
}, {
  timestamps: true
});
export default mongoose.model<IPayment>('Payment', PaymentSchema);
</file>

<file path="services/payment-service/src/routes/paymentRoutes.ts">
import { Router } from 'express';
import PaymentController from '../controllers/PaymentController';
const router = Router();
router.post('/', PaymentController.processPayment);
router.get('/:id', PaymentController.getPaymentStatus);
export default router;
</file>

<file path="services/restaurant-service/models/menu.model.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IModifierOption extends Document {
  name: string;
  price: number;
  isAvailable: boolean;
}
export interface IModifierGroup extends Document {
  name: string;
  required: boolean;
  multiSelect: boolean;
  minSelect?: number;
  maxSelect?: number;
  options: IModifierOption[];
}
export interface IMenuItem extends Document {
  _id: mongoose.Types.ObjectId;
  name: string;
  description: string;
  category: string;
  price: number;
  modifierGroups: IModifierGroup[];
  image?: string;
  preparationTime: number;
  isAvailable: boolean;
  allergens: string[];
  nutritionalInfo?: {
    calories: number;
    protein: number;
    carbohydrates: number;
    fats: number;
  };
}
export interface IMenuCategory extends Document {
  _id: mongoose.Types.ObjectId;
  name: string;
  description?: string;
  categories: string[];
  items: IMenuItem[];
  isAvailable: boolean;
  availabilitySchedule?: {
    startTime: string;
    endTime: string;
    daysOfWeek: number[];
  };
}
export interface IMenu extends Document {
  name: string;
  description?: string;
  restaurantId: mongoose.Types.ObjectId;
  categories: IMenuCategory[];
  isActive: boolean;
}
const ModifierOptionSchema: Schema = new Schema({
  name: {
    type: String,
    required: true
  },
  price: {
    type: Number,
    required: true,
    min: 0
  },
  isAvailable: {
    type: Boolean,
    default: true
  }
});
const ModifierGroupSchema: Schema = new Schema({
  name: {
    type: String,
    required: true
  },
  required: {
    type: Boolean,
    default: false
  },
  multiSelect: {
    type: Boolean,
    default: false
  },
  minSelect: {
    type: Number,
    min: 0,
    default: 0
  },
  maxSelect: {
    type: Number,
    min: 0,
    validate: {
      validator: function(this: any, value: number): boolean {
        return !this.minSelect || value >= this.minSelect;
      },
      message: 'maxSelect must be greater than or equal to minSelect'
    }
  },
  options: [ModifierOptionSchema]
});
const MenuItemSchema: Schema = new Schema({
  name: {
    type: String,
    required: true
  },
  description: {
    type: String,
    required: true
  },
  category: {
    type: String,
    required: true
  },
  price: {
    type: Number,
    required: true,
    min: 0
  },
  modifierGroups: [ModifierGroupSchema],
  image: String,
  preparationTime: {
    type: Number,
    required: true,
    min: 0
  },
  isAvailable: {
    type: Boolean,
    default: true
  },
  allergens: [String],
  nutritionalInfo: {
    calories: Number,
    protein: Number,
    carbohydrates: Number,
    fats: Number
  }
});
const MenuCategorySchema: Schema = new Schema({
  name: {
    type: String,
    required: true
  },
  description: String,
  categories: [String],
  items: [MenuItemSchema],
  isAvailable: {
    type: Boolean,
    default: true
  },
  availabilitySchedule: {
    startTime: String,
    endTime: String,
    daysOfWeek: [Number]
  }
});
const MenuSchema: Schema = new Schema({
  name: {
    type: String,
    required: true
  },
  description: String,
  restaurantId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Restaurant'
  },
  categories: [MenuCategorySchema],
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});
export default mongoose.model<IMenu>('Menu', MenuSchema);
</file>

<file path="services/restaurant-service/src/config/swagger.ts">
import swaggerJsdoc from 'swagger-jsdoc';
import { Express, Request, Response } from 'express';
import swaggerUi from 'swagger-ui-express';
import path from 'path';
const options: swaggerJsdoc.Options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'INSEAT Restaurant Service API',
      description: 'API documentation for the INSEAT restaurant management system',
      contact: {
        name: 'INSEAT Support',
        email: 'support@inseat.com',
        url: 'https://inseat.com'
      },
      version: '1.0.0',
    },
    servers: [
      {
        url: 'http://localhost:3000/api',
        description: 'Development server'
      }
    ],
    components: {
      schemas: {
        Location: {
          type: 'object',
          properties: {
            address: { type: 'string' },
            coordinates: {
              type: 'object',
              properties: {
                latitude: { type: 'number' },
                longitude: { type: 'number' },
              },
            },
          },
        },
        Venue: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            description: { type: 'string' },
            capacity: { type: 'number' },
            isActive: { type: 'boolean' },
          },
        },
        Table: {
          type: 'object',
          properties: {
            number: { type: 'string' },
            capacity: { type: 'number' },
            type: { type: 'string' },
            isOccupied: { type: 'boolean' },
            isActive: { type: 'boolean' },
            qrCode: { type: 'string' },
          },
        },
        MenuItem: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            description: { type: 'string' },
            price: { type: 'number' },
            modifiers: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  name: { type: 'string' },
                  options: { type: 'array', items: { type: 'string' } },
                  price: { type: 'number' },
                },
              },
            },
            isAvailable: { type: 'boolean' },
            schedule: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  dayOfWeek: { type: 'number' },
                  openTime: { type: 'string' },
                  closeTime: { type: 'string' },
                  isAvailable: { type: 'boolean' },
                },
              },
            },
          },
        },
        Restaurant: {
          type: 'object',
          required: ['name'],
          properties: {
            name: { type: 'string' },
            locations: {
              type: 'array',
              items: { $ref: '#/components/schemas/Location' },
            },
            venues: {
              type: 'array',
              items: { $ref: '#/components/schemas/Venue' },
            },
            tables: {
              type: 'array',
              items: { $ref: '#/components/schemas/Table' },
            },
            menu: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  category: { type: 'string' },
                  items: {
                    type: 'array',
                    items: { $ref: '#/components/schemas/MenuItem' },
                  },
                },
              },
            },
            adminIds: {
              type: 'array',
              items: { type: 'string' },
            },
            schedule: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  dayOfWeek: { type: 'number' },
                  openTime: { type: 'string' },
                  closeTime: { type: 'string' },
                  isHoliday: { type: 'boolean' },
                },
              },
            },
          },
        },
      },
    },
  },
  apis: [
    path.join(__dirname, '../controllers/*.ts'),
    path.join(__dirname, '../routes/*.ts')
  ]
};
const swaggerSpec = swaggerJsdoc(options);
function swaggerDocs(app: Express, port: number) {
  // Swagger Page
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
  // Docs in JSON format
  app.get('/api-docs.json', (req: Request, res: Response) => {
    res.setHeader('Content-Type', 'application/json');
    res.send(swaggerSpec);
  });
  console.log(`📝 Swagger Docs available at http://localhost:${port}/api-docs`);
}
export default swaggerDocs;
</file>

<file path="services/restaurant-service/src/controllers/CategoryController.ts">
import { Request, Response } from 'express';
import Category, { ICategory } from '../models/Category';
import mongoose from 'mongoose';
export class CategoryController {
  // Create a new category
  public async create(req: Request, res: Response): Promise<void> {
    try {
      console.log('Creating new category with data:', req.body);
      const { name, description, isActive, order } = req.body;
      // Validate required fields
      if (!name) {
        res.status(400).json({ error: 'Category name is required' });
        return;
      }
      // Create a new category
      const category = new Category({
        name,
        description: description || '',
        isActive: isActive !== undefined ? isActive : true,
        order: order || 0
      });
      console.log('Saving category to database...');
      const savedCategory = await category.save();
      console.log('Category saved successfully:', savedCategory);
      res.status(201).json(savedCategory);
    } catch (error) {
      console.error('Error creating category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error creating category: ${errorMessage}` });
    }
  }
  // Get all categories
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const categories = await Category.find().sort({ order: 1 });
      res.status(200).json(categories);
    } catch (error) {
      console.error('Error fetching categories:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching categories: ${errorMessage}` });
    }
  }
  // Get category by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID format
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid category ID format' });
        return;
      }
      const category = await Category.findById(id);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      res.status(200).json(category);
    } catch (error) {
      console.error('Error fetching category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching category: ${errorMessage}` });
    }
  }
  // Update category
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;
      // Validate ID format
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid category ID format' });
        return;
      }
      const category = await Category.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      );
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      res.status(200).json(category);
    } catch (error) {
      console.error('Error updating category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating category: ${errorMessage}` });
    }
  }
  // Delete category
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID format
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid category ID format' });
        return;
      }
      const category = await Category.findByIdAndDelete(id);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      res.status(200).json({ message: 'Category deleted successfully' });
    } catch (error) {
      console.error('Error deleting category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting category: ${errorMessage}` });
    }
  }
  // Toggle category availability
  public async toggleAvailability(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID format
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid category ID format' });
        return;
      }
      const category = await Category.findById(id);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      // Toggle the isActive field
      category.isActive = !category.isActive;
      await category.save();
      res.status(200).json(category);
    } catch (error) {
      console.error('Error toggling category availability:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error toggling category availability: ${errorMessage}` });
    }
  }
}
</file>

<file path="services/restaurant-service/src/controllers/MenuController.ts">
import { Request, Response } from 'express';
import Restaurant from '../models/Restaurant';
import Table, { ITable } from '../models/Table';
import Menu, { IMenuItem, IMenuCategory, IMenu } from '../../models/menu.model';
import mongoose from 'mongoose';
// Extended interface for tables with menu assignment
interface ITableWithMenu extends ITable {
  menuId?: mongoose.Types.ObjectId;
}
export class MenuController {
  // Create a new menu
  public async create(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId } = req.params;
      const menuData = req.body;
      const restaurant = await Restaurant.findById(restaurantId).exec();
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      const menu = new Menu({
        ...menuData,
        restaurantId
      });
      const savedMenu = await menu.save();
      res.status(201).json(savedMenu);
    } catch (error) {
      console.error('Error creating menu:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error creating menu: ${errorMessage}` });
    }
  }
  // Get all menus
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId } = req.params;
      const menus = await Menu.find({ restaurantId }).exec();
      res.status(200).json(menus);
    } catch (error) {
      console.error('Error fetching menus:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching menus: ${errorMessage}` });
    }
  }
  // Get menu by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const { menuId } = req.params;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      res.status(200).json(menu);
    } catch (error) {
      console.error('Error fetching menu:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching menu: ${errorMessage}` });
    }
  }
  // Update menu
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const { menuId } = req.params;
      const updateData = req.body;
      const menu = await Menu.findByIdAndUpdate(
        menuId,
        updateData,
        { new: true }
      ).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      res.status(200).json(menu);
    } catch (error) {
      console.error('Error updating menu:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating menu: ${errorMessage}` });
    }
  }
  // Delete menu
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const { menuId } = req.params;
      const menu = await Menu.findByIdAndDelete(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      res.status(200).json({ message: 'Menu deleted successfully' });
    } catch (error) {
      console.error('Error deleting menu:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting menu: ${errorMessage}` });
    }
  }
  // Add category to menu
  public async addCategory(req: Request, res: Response): Promise<void> {
    try {
      const { menuId } = req.params;
      const categoryData = req.body;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      // Create category as a mongoose subdocument
      const categorySchema = (Menu.schema.path('categories') as any).schema;
      const CategoryModel = mongoose.model('MenuCategory', categorySchema);
      const category = new CategoryModel({
        _id: new mongoose.Types.ObjectId(),
        name: categoryData.name,
        description: categoryData.description,
        categories: categoryData.categories || [],
        items: [],
        isAvailable: true,
        availabilitySchedule: categoryData.availabilitySchedule
      });
      // Add to categories array
      menu.categories.push(category as any);
      await menu.save();
      res.status(201).json(category.toObject());
    } catch (error) {
      console.error('Error adding category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error adding category: ${errorMessage}` });
    }
  }
  // Add menu item to category
  public async addMenuItem(req: Request, res: Response): Promise<void> {
    try {
      const { menuId, categoryId } = req.params;
      const itemData = req.body;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      const category = menu.categories.find((cat: IMenuCategory) => cat._id?.toString() === categoryId);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      const newItem: Partial<IMenuItem> = {
        _id: new mongoose.Types.ObjectId(),
        name: itemData.name,
        description: itemData.description,
        category: itemData.category,
        price: itemData.price,
        modifierGroups: itemData.modifierGroups || [],
        image: itemData.image,
        preparationTime: itemData.preparationTime,
        isAvailable: true,
        allergens: itemData.allergens || [],
        nutritionalInfo: itemData.nutritionalInfo
      };
      category.items.push(newItem as IMenuItem);
      await menu.save();
      res.status(201).json(newItem);
    } catch (error) {
      console.error('Error adding menu item:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error adding menu item: ${errorMessage}` });
    }
  }
  // Update menu item availability
  public async updateItemAvailability(req: Request, res: Response): Promise<void> {
    try {
      const { menuId, categoryId, itemId } = req.params;
      const { isAvailable } = req.body;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      const category = menu.categories.find((cat: IMenuCategory) => cat._id?.toString() === categoryId);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      const item = category.items.find((item: IMenuItem) => item._id?.toString() === itemId);
      if (!item) {
        res.status(404).json({ error: 'Item not found' });
        return;
      }
      item.isAvailable = isAvailable;
      await menu.save();
      res.status(200).json(item);
    } catch (error) {
      console.error('Error updating item availability:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating item availability: ${errorMessage}` });
    }
  }
  // Assign menu to table
  public async assignMenuToTable(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId, menuId } = req.params;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Find the table in the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      // Update the table with the menu ID and save
      const updatedTable = await Table.findByIdAndUpdate(
        tableId,
        { menuId: menu._id },
        { new: true }
      );
      res.status(200).json(updatedTable);
    } catch (error) {
      console.error('Error assigning menu to table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error assigning menu to table: ${errorMessage}` });
    }
  }
  // Remove menu from table
  public async removeMenuFromTable(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Find the table in the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      // Update the table to remove the menu ID and save
      const updatedTable = await Table.findByIdAndUpdate(
        tableId,
        { $unset: { menuId: 1 } },
        { new: true }
      );
      res.status(200).json(updatedTable);
    } catch (error) {
      console.error('Error removing menu from table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error removing menu from table: ${errorMessage}` });
    }
  }
  // Get all menu categories
  public async getCategories(req: Request, res: Response): Promise<void> {
    try {
      const { menuId } = req.params;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      res.status(200).json(menu.categories);
    } catch (error) {
      console.error('Error fetching menu categories:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching menu categories: ${errorMessage}` });
    }
  }
  // Update menu category
  public async updateCategory(req: Request, res: Response): Promise<void> {
    try {
      const { menuId, categoryId } = req.params;
      const updateData = req.body;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      const category = menu.categories.find((cat: IMenuCategory) => cat._id?.toString() === categoryId);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      category.name = updateData.name;
      category.description = updateData.description;
      category.categories = updateData.categories || [];
      category.isAvailable = updateData.isAvailable;
      category.availabilitySchedule = updateData.availabilitySchedule;
      await menu.save();
      res.status(200).json(category);
    } catch (error) {
      console.error('Error updating menu category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating menu category: ${errorMessage}` });
    }
  }
  // Delete menu category
  public async deleteCategory(req: Request, res: Response): Promise<void> {
    try {
      const { menuId, categoryId } = req.params;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      const categoryIndex = menu.categories.findIndex((cat: IMenuCategory) => cat._id?.toString() === categoryId);
      if (categoryIndex === -1) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      menu.categories.splice(categoryIndex, 1);
      await menu.save();
      res.status(200).json({ message: 'Menu category deleted successfully' });
    } catch (error) {
      console.error('Error deleting menu category:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting menu category: ${errorMessage}` });
    }
  }
  // Update menu item
  public async updateMenuItem(req: Request, res: Response): Promise<void> {
    try {
      const { menuId, categoryId, itemId } = req.params;
      const updateData = req.body;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      const category = menu.categories.find((cat: IMenuCategory) => cat._id?.toString() === categoryId);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      const item = category.items.find((item: IMenuItem) => item._id?.toString() === itemId);
      if (!item) {
        res.status(404).json({ error: 'Item not found' });
        return;
      }
      item.name = updateData.name;
      item.description = updateData.description;
      item.price = updateData.price;
      item.modifierGroups = updateData.modifierGroups || [];
      item.image = updateData.image;
      item.preparationTime = updateData.preparationTime;
      item.isAvailable = updateData.isAvailable;
      item.allergens = updateData.allergens || [];
      item.nutritionalInfo = updateData.nutritionalInfo;
      await menu.save();
      res.status(200).json(item);
    } catch (error) {
      console.error('Error updating menu item:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating menu item: ${errorMessage}` });
    }
  }
  // Delete menu item
  public async deleteMenuItem(req: Request, res: Response): Promise<void> {
    try {
      const { menuId, categoryId, itemId } = req.params;
      const menu = await Menu.findById(menuId).exec();
      if (!menu) {
        res.status(404).json({ error: 'Menu not found' });
        return;
      }
      const category = menu.categories.find((cat: IMenuCategory) => cat._id?.toString() === categoryId);
      if (!category) {
        res.status(404).json({ error: 'Category not found' });
        return;
      }
      const itemIndex = category.items.findIndex((item: IMenuItem) => item._id?.toString() === itemId);
      if (itemIndex === -1) {
        res.status(404).json({ error: 'Item not found' });
        return;
      }
      category.items.splice(itemIndex, 1);
      await menu.save();
      res.status(200).json({ message: 'Menu item deleted successfully' });
    } catch (error) {
      console.error('Error deleting menu item:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting menu item: ${errorMessage}` });
    }
  }
}
</file>

<file path="services/restaurant-service/src/controllers/ModifierController.ts">
import { Request, Response } from 'express';
import Modifier, { IModifier } from '../models/Modifier';
import mongoose from 'mongoose';
export class ModifierController {
  // Create a new modifier
  public async create(req: Request, res: Response): Promise<void> {
    try {
      console.log('Creating new modifier with data:', req.body);
      const modifierData = req.body;
      // Validate required fields
      if (!modifierData.name) {
        res.status(400).json({ error: 'Modifier name is required' });
        return;
      }
      // Validate price is a number
      if (isNaN(Number(modifierData.price))) {
        res.status(400).json({ error: 'Price must be a valid number' });
        return;
      }
      const modifier = new Modifier(modifierData);
      console.log('Saving modifier to database...');
      const savedModifier = await modifier.save();
      console.log('Modifier saved successfully:', savedModifier);
      res.status(201).json(savedModifier);
    } catch (error) {
      console.error('Error creating modifier:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error creating modifier: ${errorMessage}` });
    }
  }
  // Get all modifiers
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const modifiers = await Modifier.find();
      res.status(200).json(modifiers);
    } catch (error) {
      console.error('Error fetching modifiers:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching modifiers: ${errorMessage}` });
    }
  }
  // Get modifier by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid modifier ID format' });
        return;
      }
      const modifier = await Modifier.findById(id);
      if (!modifier) {
        res.status(404).json({ error: 'Modifier not found' });
        return;
      }
      res.status(200).json(modifier);
    } catch (error) {
      console.error('Error fetching modifier:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching modifier: ${errorMessage}` });
    }
  }
  // Update modifier
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid modifier ID format' });
        return;
      }
      // Validate price is a number if provided
      if (updateData.price !== undefined && isNaN(Number(updateData.price))) {
        res.status(400).json({ error: 'Price must be a valid number' });
        return;
      }
      const modifier = await Modifier.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      );
      if (!modifier) {
        res.status(404).json({ error: 'Modifier not found' });
        return;
      }
      res.status(200).json(modifier);
    } catch (error) {
      console.error('Error updating modifier:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating modifier: ${errorMessage}` });
    }
  }
  // Delete modifier
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid modifier ID format' });
        return;
      }
      const modifier = await Modifier.findByIdAndDelete(id);
      if (!modifier) {
        res.status(404).json({ error: 'Modifier not found' });
        return;
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting modifier:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting modifier: ${errorMessage}` });
    }
  }
  // Toggle modifier availability
  public async toggleAvailability(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid modifier ID format' });
        return;
      }
      const modifier = await Modifier.findById(id);
      if (!modifier) {
        res.status(404).json({ error: 'Modifier not found' });
        return;
      }
      modifier.isAvailable = !modifier.isAvailable;
      await modifier.save();
      res.status(200).json(modifier);
    } catch (error) {
      console.error('Error toggling modifier availability:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error toggling modifier availability: ${errorMessage}` });
    }
  }
}
</file>

<file path="services/restaurant-service/src/controllers/RestaurantController.ts">
import { Request, Response } from 'express';
import Restaurant, { IRestaurant } from '../models/Restaurant';
import Venue from '../models/Venue';
import QRCode from 'qrcode';
export class RestaurantController {
  /**
   * @swagger
   * /restaurants:
   *   post:
   *     summary: Create a new restaurant
   *     tags: [Restaurants]
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/Restaurant'
   *     responses:
   *       201:
   *         description: Restaurant created successfully
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/Restaurant'
   *       500:
   *         description: Server error
   */
  public async create(req: Request, res: Response): Promise<void> {
    try {
      console.log('Creating restaurant with data:', req.body);
      const restaurantData = req.body;
      // Generate QR codes for tables
      if (restaurantData.tables) {
        console.log('Generating QR codes for tables:', restaurantData.tables);
        for (let table of restaurantData.tables) {
          table.qrCode = await QRCode.toDataURL(`table-${table.tableNumber}`);
        }  
      }
      console.log('Creating new Restaurant model with data:', restaurantData);
      const restaurant = new Restaurant(restaurantData);
      console.log('Saving restaurant to database...');
      const savedRestaurant = await restaurant.save();
      console.log('Restaurant saved successfully:', savedRestaurant);
      res.status(201).json(savedRestaurant);
    } catch (error) {
      console.error('Error creating restaurant:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error creating restaurant: ${errorMessage}` });
    }
  }
  /**
   * @swagger
   * /restaurants:
   *   get:
   *     summary: Get all restaurants
   *     tags: [Restaurants]
   *     responses:
   *       200:
   *         description: List of restaurants
   *         content:
   *           application/json:
   *             schema:
   *               type: array
   *               items:
   *                 $ref: '#/components/schemas/Restaurant'
   *       500:
   *         description: Server error
   */
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const restaurants = await Restaurant.find();
      res.status(200).json(restaurants);
    } catch (error) {
      res.status(500).json({ error: 'Error fetching restaurants' });
    }
  }
  /**
   * @swagger
   * /restaurants/{id}:
   *   get:
   *     summary: Get restaurant by ID
   *     tags: [Restaurants]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Restaurant found
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/Restaurant'
   *       404:
   *         description: Restaurant not found
   *       500:
   *         description: Server error
   */
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const restaurant = await Restaurant.findById(req.params.id);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      res.status(200).json(restaurant);
    } catch (error) {
      res.status(500).json({ error: 'Error fetching restaurant' });
    }
  }
  /**
   * @swagger
   * /restaurants/{id}:
   *   put:
   *     summary: Update restaurant
   *     tags: [Restaurants]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/Restaurant'
   *     responses:
   *       200:
   *         description: Restaurant updated successfully
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/Restaurant'
   *       404:
   *         description: Restaurant not found
   *       500:
   *         description: Server error
   */
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const restaurant = await Restaurant.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true }
      );
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      res.status(200).json(restaurant);
    } catch (error) {
      res.status(500).json({ error: 'Error updating restaurant' });
    }
  }
  /**
   * @swagger
   * /restaurants/{id}:
   *   delete:
   *     summary: Delete restaurant
   *     tags: [Restaurants]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: Restaurant deleted successfully
   *       404:
   *         description: Restaurant not found
   *       500:
   *         description: Server error
   */
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const restaurant = await Restaurant.findByIdAndDelete(req.params.id);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      res.status(200).json({ message: 'Restaurant deleted successfully' });
    } catch (error) {
      res.status(500).json({ error: 'Error deleting restaurant' });
    }
  }
  /**
   * @swagger
   * /restaurants/{id}/menu-categories:
   *   post:
   *     summary: Add menu category
   *     tags: [Menu]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - category
   *             properties:
   *               category:
   *                 type: string
   *               items:
   *                 type: array
   *                 items:
   *                   $ref: '#/components/schemas/MenuItem'
   *     responses:
   *       200:
   *         description: Menu category added successfully
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/Restaurant'
   *       404:
   *         description: Restaurant not found
   *       500:
   *         description: Server error
   */
  public async addMenuCategory(req: Request, res: Response): Promise<void> {
    try {
      const { category } = req.body;
      const restaurant = await Restaurant.findByIdAndUpdate(
        req.params.id,
        { $push: { menu: { category, items: [] } } },
        { new: true }
      );
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      res.status(200).json(restaurant);
    } catch (error) {
      res.status(500).json({ error: 'Error adding menu category' });
    }
  }
  /**
   * @swagger
   * /restaurants/{id}/menu-items:
   *   post:
   *     summary: Add menu item
   *     tags: [Menu]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             $ref: '#/components/schemas/MenuItem'
   *     responses:
   *       200:
   *         description: Menu item added successfully
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/Restaurant'
   *       404:
   *         description: Restaurant or category not found
   *       500:
   *         description: Server error
   */
  public async addMenuItem(req: Request, res: Response): Promise<void> {
    try {
      const { categoryId, item } = req.body;
      const restaurant = await Restaurant.findOneAndUpdate(
        { _id: req.params.id, 'menu._id': categoryId },
        { $push: { 'menu.$.items': item } },
        { new: true }
      );
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or category not found' });
        return;
      }
      res.status(200).json(restaurant);
    } catch (error) {
      res.status(500).json({ error: 'Error adding menu item' });
    }
  }
  /**
   * @swagger
   * /restaurants/{id}/table-status:
   *   put:
   *     summary: Update table status
   *     tags: [Tables]
   *     parameters:
   *       - in: path
   *         name: id
   *         required: true
   *         schema:
   *           type: string
   *     requestBody:
   *       required: true
   *       content:
   *         application/json:
   *           schema:
   *             type: object
   *             required:
   *               - tableNumber
   *               - isOccupied
   *             properties:
   *               tableNumber:
   *                 type: string
   *               isOccupied:
   *                 type: boolean
   *     responses:
   *       200:
   *         description: Table status updated successfully
   *         content:
   *           application/json:
   *             schema:
   *               $ref: '#/components/schemas/Restaurant'
   *       404:
   *         description: Restaurant or table not found
   *       500:
   *         description: Server error
   */
  public async updateTableStatus(req: Request, res: Response): Promise<void> {
    try {
      const { tableNumber, isOccupied } = req.body;
      const restaurant = await Restaurant.findOneAndUpdate(
        { _id: req.params.id, 'tables.tableNumber': tableNumber },
        { $set: { 'tables.$.isOccupied': isOccupied } },
        { new: true }
      );
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      res.status(200).json(restaurant);
    } catch (error) {
      res.status(500).json({ error: 'Error updating table status' });
    }
  }
  /**
   * @swagger
   * /restaurants/{restaurantId}/venues:
   *   get:
   *     summary: Get restaurant venues
   *     tags: [Venues]
   *     parameters:
   *       - in: path
   *         name: restaurantId
   *         required: true
   *         schema:
   *           type: string
   *     responses:
   *       200:
   *         description: List of venues
   *         content:
   *           application/json:
   *             schema:
   *               type: array
   *               items:
   *                 $ref: '#/components/schemas/Venue'
   *       404:
   *         description: Restaurant not found
   *       500:
   *         description: Server error
   */
  public async getVenues(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId } = req.params;
      // First check if restaurant exists
      const restaurant = await Restaurant.findById(restaurantId);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      // Fetch venues from Venue model
      const venues = await Venue.find({ restaurantId });
      res.status(200).json(venues);
    } catch (error) {
      console.error('Error fetching venues:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching venues: ${errorMessage}` });
    }
  }
}
</file>

<file path="services/restaurant-service/src/controllers/TableController.js">
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableController = void 0;
var Restaurant_1 = require("../models/Restaurant");
var Table_1 = require("../models/Table");
var QRCode = require("qrcode");
var uuid_1 = require("uuid");
var mongoose_1 = require("mongoose");
var TableController = /** @class */ (function () {
    function TableController() {
    }
    // Create a new table
    TableController.prototype.create = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, venueId_1, tableData, restaurant, venueExists, existingTable, newTable, savedTable, error_1, errorMessage;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 5, , 6]);
                        console.log('Creating table with params:', req.params);
                        console.log('Table data:', req.body);
                        _a = req.params, restaurantId = _a.restaurantId, venueId_1 = _a.venueId;
                        tableData = req.body;
                        if (!mongoose_1.default.Types.ObjectId.isValid(restaurantId)) {
                            res.status(400).json({ error: 'Invalid restaurant ID format' });
                            return [2 /*return*/];
                        }
                        if (!mongoose_1.default.Types.ObjectId.isValid(venueId_1)) {
                            res.status(400).json({ error: 'Invalid venue ID format' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Restaurant_1.default.findById(restaurantId)];
                    case 1:
                        restaurant = _c.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant not found' });
                            return [2 /*return*/];
                        }
                        venueExists = restaurant.venues.some(function (venue) { return venue.toString() === venueId_1; });
                        if (!venueExists) {
                            res.status(404).json({ error: 'Venue not found in this restaurant' });
                            return [2 /*return*/];
                        }
                        // Validate required fields
                        if (!tableData.number || !tableData.capacity || !tableData.type) {
                            res.status(400).json({ error: 'Missing required fields: number, capacity, or type' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findOne({
                                venueId: new mongoose_1.default.Types.ObjectId(venueId_1),
                                number: tableData.number
                            })];
                    case 2:
                        existingTable = _c.sent();
                        if (existingTable) {
                            res.status(400).json({ error: 'Table number already exists in this venue' });
                            return [2 /*return*/];
                        }
                        newTable = new Table_1.default({
                            number: tableData.number,
                            capacity: parseInt(tableData.capacity, 10),
                            type: tableData.type,
                            venueId: new mongoose_1.default.Types.ObjectId(venueId_1),
                            qrCode: '',
                            isOccupied: false,
                            isActive: (_b = tableData.isActive) !== null && _b !== void 0 ? _b : true
                        });
                        console.log('Attempting to save new table:', newTable);
                        return [4 /*yield*/, newTable.save()];
                    case 3:
                        savedTable = _c.sent();
                        console.log('Table saved successfully:', savedTable);
                        // Add the table's ID to the restaurant's tables array
                        return [4 /*yield*/, Restaurant_1.default.findByIdAndUpdate(restaurantId, { $push: { tables: savedTable._id } }, { new: true })];
                    case 4:
                        // Add the table's ID to the restaurant's tables array
                        _c.sent();
                        console.log('Restaurant updated with new table');
                        res.status(201).json(savedTable);
                        return [3 /*break*/, 6];
                    case 5:
                        error_1 = _c.sent();
                        console.error('Error creating table:', error_1);
                        errorMessage = error_1 instanceof Error ? error_1.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error creating table: ".concat(errorMessage) });
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    // Get all tables
    TableController.prototype.getAll = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, venueId_2, restaurant, venueExists, tables, error_2, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, , 4]);
                        _a = req.params, restaurantId = _a.restaurantId, venueId_2 = _a.venueId;
                        return [4 /*yield*/, Restaurant_1.default.findById(restaurantId)];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant not found' });
                            return [2 /*return*/];
                        }
                        venueExists = restaurant.venues.some(function (venue) { return venue.toString() === venueId_2; });
                        if (!venueExists) {
                            res.status(404).json({ error: 'Venue not found in this restaurant' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.find({ venueId: new mongoose_1.default.Types.ObjectId(venueId_2) })];
                    case 2:
                        tables = _b.sent();
                        res.json(tables);
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _b.sent();
                        console.error('Error getting tables:', error_2);
                        errorMessage = error_2 instanceof Error ? error_2.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error getting tables: ".concat(errorMessage) });
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    // Get table by ID
    TableController.prototype.getById = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, tableId, restaurant, table, error_3, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, , 4]);
                        _a = req.params, restaurantId = _a.restaurantId, tableId = _a.tableId;
                        return [4 /*yield*/, Restaurant_1.default.findOne({
                                _id: restaurantId,
                                tables: { $in: [tableId] }
                            })];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant or table not found' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findById(tableId)];
                    case 2:
                        table = _b.sent();
                        if (!table) {
                            res.status(404).json({ error: 'Table not found' });
                            return [2 /*return*/];
                        }
                        res.json(table);
                        return [3 /*break*/, 4];
                    case 3:
                        error_3 = _b.sent();
                        console.error('Error getting table:', error_3);
                        errorMessage = error_3 instanceof Error ? error_3.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error getting table: ".concat(errorMessage) });
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    // Update table
    TableController.prototype.update = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, tableId, updateData, restaurant, table, updatedTable, error_4, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 4, , 5]);
                        _a = req.params, restaurantId = _a.restaurantId, tableId = _a.tableId;
                        updateData = req.body;
                        return [4 /*yield*/, Restaurant_1.default.findOne({
                                _id: restaurantId,
                                tables: { $in: [tableId] }
                            })];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant or table not found' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findById(tableId)];
                    case 2:
                        table = _b.sent();
                        if (!table) {
                            res.status(404).json({ error: 'Table not found' });
                            return [2 /*return*/];
                        }
                        // Ensure venueId is always present
                        if (!updateData.venueId && !table.venueId) {
                            res.status(400).json({ error: 'venueId is required' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findByIdAndUpdate(tableId, __assign({}, updateData), { new: true, runValidators: true })];
                    case 3:
                        updatedTable = _b.sent();
                        res.json(updatedTable);
                        return [3 /*break*/, 5];
                    case 4:
                        error_4 = _b.sent();
                        console.error('Error updating table:', error_4);
                        errorMessage = error_4 instanceof Error ? error_4.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error updating table: ".concat(errorMessage) });
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    // Delete table
    TableController.prototype.delete = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, tableId, restaurant, table, error_5, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, , 6]);
                        _a = req.params, restaurantId = _a.restaurantId, tableId = _a.tableId;
                        return [4 /*yield*/, Restaurant_1.default.findById(restaurantId)];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant not found' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findById(tableId)];
                    case 2:
                        table = _b.sent();
                        if (!table) {
                            res.status(404).json({ error: 'Table not found' });
                            return [2 /*return*/];
                        }
                        // Remove the table ID from the restaurant's tables array
                        return [4 /*yield*/, Restaurant_1.default.updateOne({ _id: restaurantId }, { $pull: { tables: tableId } })];
                    case 3:
                        // Remove the table ID from the restaurant's tables array
                        _b.sent();
                        // Delete the table document from the Table collection
                        return [4 /*yield*/, Table_1.default.findByIdAndDelete(tableId)];
                    case 4:
                        // Delete the table document from the Table collection
                        _b.sent();
                        res.status(204).send();
                        return [3 /*break*/, 6];
                    case 5:
                        error_5 = _b.sent();
                        console.error('Error deleting table:', error_5);
                        errorMessage = error_5 instanceof Error ? error_5.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error deleting table: ".concat(errorMessage) });
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    // Generate QR code for a table
    TableController.prototype.generateQRCode = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, tableId, restaurant, table, qrData, qrCode, error_6, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, , 6]);
                        _a = req.params, restaurantId = _a.restaurantId, tableId = _a.tableId;
                        return [4 /*yield*/, Restaurant_1.default.findOne({
                                _id: restaurantId,
                                tables: { $in: [tableId] }
                            })];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant or table not found' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findById(tableId)];
                    case 2:
                        table = _b.sent();
                        if (!table) {
                            res.status(404).json({ error: 'Table not found' });
                            return [2 /*return*/];
                        }
                        qrData = {
                            restaurantId: restaurantId,
                            tableId: tableId,
                            uniqueId: (0, uuid_1.v4)()
                        };
                        return [4 /*yield*/, QRCode.toDataURL(JSON.stringify(qrData))];
                    case 3:
                        qrCode = _b.sent();
                        // Update the table with the QR code
                        table.qrCode = qrCode;
                        return [4 /*yield*/, table.save()];
                    case 4:
                        _b.sent();
                        res.json({ qrCode: qrCode });
                        return [3 /*break*/, 6];
                    case 5:
                        error_6 = _b.sent();
                        console.error('Error generating QR code:', error_6);
                        errorMessage = error_6 instanceof Error ? error_6.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error generating QR code: ".concat(errorMessage) });
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    // Get QR code for a table
    TableController.prototype.getQRCode = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, tableId, restaurant, table, error_7, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 3, , 4]);
                        _a = req.params, restaurantId = _a.restaurantId, tableId = _a.tableId;
                        return [4 /*yield*/, Restaurant_1.default.findOne({
                                _id: restaurantId,
                                tables: { $in: [tableId] }
                            })];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant or table not found' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findById(tableId)];
                    case 2:
                        table = _b.sent();
                        if (!table) {
                            res.status(404).json({ error: 'Table not found' });
                            return [2 /*return*/];
                        }
                        if (!table.qrCode) {
                            res.status(404).json({ error: 'QR code not found for this table' });
                            return [2 /*return*/];
                        }
                        res.json({ qrCode: table.qrCode });
                        return [3 /*break*/, 4];
                    case 3:
                        error_7 = _b.sent();
                        console.error('Error getting QR code:', error_7);
                        errorMessage = error_7 instanceof Error ? error_7.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error getting QR code: ".concat(errorMessage) });
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    // Delete QR code for a table
    TableController.prototype.deleteQRCode = function (req, res) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, restaurantId, tableId, restaurant, table, error_8, errorMessage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 4, , 5]);
                        _a = req.params, restaurantId = _a.restaurantId, tableId = _a.tableId;
                        return [4 /*yield*/, Restaurant_1.default.findOne({
                                _id: restaurantId,
                                tables: { $in: [tableId] }
                            })];
                    case 1:
                        restaurant = _b.sent();
                        if (!restaurant) {
                            res.status(404).json({ error: 'Restaurant or table not found' });
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Table_1.default.findById(tableId)];
                    case 2:
                        table = _b.sent();
                        if (!table) {
                            res.status(404).json({ error: 'Table not found' });
                            return [2 /*return*/];
                        }
                        // Remove the QR code
                        table.qrCode = '';
                        return [4 /*yield*/, table.save()];
                    case 3:
                        _b.sent();
                        res.status(204).send();
                        return [3 /*break*/, 5];
                    case 4:
                        error_8 = _b.sent();
                        console.error('Error deleting QR code:', error_8);
                        errorMessage = error_8 instanceof Error ? error_8.message : 'Unknown error occurred';
                        res.status(500).json({ error: "Error deleting QR code: ".concat(errorMessage) });
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return TableController;
}());
exports.TableController = TableController;
</file>

<file path="services/restaurant-service/src/controllers/TableController.ts">
import { Request, Response } from 'express';
import Restaurant from '../models/Restaurant';
import Table, { ITable } from '../models/Table';
import * as QRCode from 'qrcode';
import { v4 as uuidv4 } from 'uuid';
import mongoose from 'mongoose';
export class TableController {
  // Create a new table
  public async create(req: Request, res: Response): Promise<void> {
    try {
      console.log('Creating table with params:', req.params);
      console.log('Table data:', req.body);
      const { restaurantId, venueId } = req.params;
      const tableData = req.body;
      if (!mongoose.Types.ObjectId.isValid(restaurantId)) {
        res.status(400).json({ error: 'Invalid restaurant ID format' });
        return;
      }
      if (!mongoose.Types.ObjectId.isValid(venueId)) {
        res.status(400).json({ error: 'Invalid venue ID format' });
        return;
      }
      // Check if restaurant exists
      const restaurant = await Restaurant.findById(restaurantId);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      // Check if venue exists in restaurant
      const venueExists = restaurant.venues.some(venue => venue.toString() === venueId);
      if (!venueExists) {
        res.status(404).json({ error: 'Venue not found in this restaurant' });
        return;
      }
      // Validate required fields
      if (!tableData.number || !tableData.capacity || !tableData.type) {
        res.status(400).json({ error: 'Missing required fields: number, capacity, or type' });
        return;
      }
      // Check if table number already exists in this venue
      const existingTable = await Table.findOne({
        venueId: new mongoose.Types.ObjectId(venueId),
        number: tableData.number
      });
      if (existingTable) {
        res.status(400).json({ error: 'Table number already exists in this venue' });
        return;
      }
      // Create a new table document
      const newTable = new Table({
        number: tableData.number,
        capacity: parseInt(tableData.capacity, 10),
        type: tableData.type,
        venueId: new mongoose.Types.ObjectId(venueId),
        qrCode: '',
        isOccupied: false,
        isActive: tableData.isActive ?? true
      });
      console.log('Attempting to save new table:', newTable);
      // Save the new table to the Table collection
      const savedTable = await newTable.save();
      console.log('Table saved successfully:', savedTable);
      // Add the table's ID to the restaurant's tables array
      await Restaurant.findByIdAndUpdate(
        restaurantId,
        { $push: { tables: savedTable._id } },
        { new: true }
      );
      console.log('Restaurant updated with new table');
      res.status(201).json(savedTable);
    } catch (error) {
      console.error('Error creating table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error creating table: ${errorMessage}` });
    }
  }
  // Get all tables
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, venueId } = req.params;
      // First check if restaurant exists
      const restaurant = await Restaurant.findById(restaurantId);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      // Check if venue exists in restaurant
      const venueExists = restaurant.venues.some(venue => venue.toString() === venueId);
      if (!venueExists) {
        res.status(404).json({ error: 'Venue not found in this restaurant' });
        return;
      }
      // Query tables directly by venueId
      const tables = await Table.find({ venueId: new mongoose.Types.ObjectId(venueId) });
      res.json(tables);
    } catch (error) {
      console.error('Error getting tables:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error getting tables: ${errorMessage}` });
    }
  }
  // Get table by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Get the table from the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      res.json(table);
    } catch (error) {
      console.error('Error getting table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error getting table: ${errorMessage}` });
    }
  }
  // Update table
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      const updateData = req.body;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Find and update the table in the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      // Ensure venueId is always present
      if (!updateData.venueId && !table.venueId) {
        res.status(400).json({ error: 'venueId is required' });
        return;
      }
      // Update the table document
      const updatedTable = await Table.findByIdAndUpdate(
        tableId,
        { ...updateData },
        { new: true, runValidators: true }
      );
      res.json(updatedTable);
    } catch (error) {
      console.error('Error updating table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating table: ${errorMessage}` });
    }
  }
  // Delete table
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      // Check if restaurant exists
      const restaurant = await Restaurant.findById(restaurantId);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      // Check if table exists
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      // Remove the table ID from the restaurant's tables array
      await Restaurant.updateOne(
        { _id: restaurantId },
        { $pull: { tables: tableId } }
      );
      // Delete the table document from the Table collection
      await Table.findByIdAndDelete(tableId);
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting table: ${errorMessage}` });
    }
  }
  // Generate QR code for a table
  public async generateQRCode(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Find the table in the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      // Generate a unique identifier for the QR code
      const qrData = {
        restaurantId,
        tableId,
        uniqueId: uuidv4()
      };
      // Generate QR code
      const qrCode = await QRCode.toDataURL(JSON.stringify(qrData));
      // Update the table with the QR code
      table.qrCode = qrCode;
      await table.save();
      res.json({ qrCode });
    } catch (error) {
      console.error('Error generating QR code:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error generating QR code: ${errorMessage}` });
    }
  }
  // Get QR code for a table
  public async getQRCode(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Find the table in the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      if (!table.qrCode) {
        res.status(404).json({ error: 'QR code not found for this table' });
        return;
      }
      res.json({ qrCode: table.qrCode });
    } catch (error) {
      console.error('Error getting QR code:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error getting QR code: ${errorMessage}` });
    }
  }
  // Delete QR code for a table
  public async deleteQRCode(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId, tableId } = req.params;
      // Check if restaurant exists and contains this table ID
      const restaurant = await Restaurant.findOne({
        _id: restaurantId,
        tables: { $in: [tableId] }
      });
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant or table not found' });
        return;
      }
      // Find the table in the Table collection
      const table = await Table.findById(tableId);
      if (!table) {
        res.status(404).json({ error: 'Table not found' });
        return;
      }
      // Remove the QR code
      table.qrCode = '';
      await table.save();
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting QR code:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting QR code: ${errorMessage}` });
    }
  }
}
</file>

<file path="services/restaurant-service/src/controllers/VenueController.ts">
import { Request, Response } from 'express';
import Restaurant from '../models/Restaurant';
import Venue from '../models/Venue';
import Table from '../models/Table';
import mongoose from 'mongoose';
export class VenueController {
  // Create a new venue
  public async create(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId } = req.params;
      const { name, description, capacity, isActive } = req.body;
      // Validate required fields
      if (!name || !description || !capacity) {
        res.status(400).json({ error: 'Missing required fields: name, description, or capacity' });
        return;
      }
      // Validate capacity is a positive number
      const capacityNum = parseInt(capacity);
      if (isNaN(capacityNum) || capacityNum <= 0) {
        res.status(400).json({ error: 'Capacity must be a positive number' });
        return;
      }
      // Validate restaurantId is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(restaurantId)) {
        res.status(400).json({ error: 'Invalid restaurant ID format' });
        return;
      }
      // Find the restaurant by ID
      const restaurant = await Restaurant.findById(restaurantId);
      if (!restaurant) {
        res.status(404).json({ error: 'Restaurant not found' });
        return;
      }
      // Create a new venue document
      const venue = new Venue({
        name,
        description,
        capacity: capacityNum,
        restaurantId: new mongoose.Types.ObjectId(restaurantId),
        isActive: isActive ?? true
      });
      // Save the venue as a separate document
      const savedVenue = await venue.save();
      // Add the venue reference to the restaurant using $push
      await Restaurant.findByIdAndUpdate(
        restaurantId,
        { $push: { venues: savedVenue._id } },
        { new: true }
      );
      res.status(201).json(savedVenue);
    } catch (error) {
      console.error('Error creating venue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error creating venue', details: errorMessage, statusCode: 500 });
    }
  }
  // Get all venues
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const { restaurantId } = req.params;
      // Validate restaurantId is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(restaurantId)) {
        res.status(400).json({ error: 'Invalid restaurant ID format' });
        return;
      }
      // Find all venues for this restaurant
      const venues = await Venue.find({ restaurantId });
      res.status(200).json(venues);
    } catch (error) {
      console.error('Error fetching venues:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error fetching venues', details: errorMessage });
    }
  }
  // Get all venues
  public async getAllVenues(req: Request, res: Response): Promise<void> {
    try {
      const venues = await Venue.find().populate('restaurantId');
      res.status(200).json(venues);
    } catch (error) {
      console.error('Error fetching all venues:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ 
        error: 'Error fetching venues', 
        details: errorMessage 
      });
    }
  }
  // Get venue by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid ID format' });
        return;
      }
      const venue = await Venue.findById(id);
      if (!venue) {
        res.status(404).json({ error: 'Venue not found' });
        return;
      }
      res.status(200).json(venue);
    } catch (error) {
      console.error('Error fetching venue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error fetching venue', details: errorMessage });
    }
  }
  // Update venue
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid ID format' });
        return;
      }
      const venue = await Venue.findByIdAndUpdate(id, updateData, { new: true });
      if (!venue) {
        res.status(404).json({ error: 'Venue not found' });
        return;
      }
      res.status(200).json(venue);
    } catch (error) {
      console.error('Error updating venue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error updating venue', details: errorMessage });
    }
  }
  // Delete venue
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(id)) {
        res.status(400).json({ error: 'Invalid ID format' });
        return;
      }
      const venue = await Venue.findByIdAndRemove(id);
      if (!venue) {
        res.status(404).json({ error: 'Venue not found' });
        return;
      }
      // Remove the venue reference from the restaurant
      const restaurant = await Restaurant.findOneAndUpdate(
        { venues: id },
        { $pull: { venues: id } }
      );
      res.status(200).json({ message: 'Venue deleted successfully' });
    } catch (error) {
      console.error('Error deleting venue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error deleting venue', details: errorMessage });
    }
  }
  // Get tables of venue
  public async getTables(req: Request, res: Response): Promise<void> {
    try {
      const { venueId } = req.params;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(venueId)) {
        res.status(400).json({ error: 'Invalid ID format' });
        return;
      }
      const venue = await Venue.findById(venueId);
      if (!venue) {
        res.status(404).json({ error: 'Venue not found' });
        return;
      }
      // Get tables associated with this venue
      const tables = await Table.find({ venueId });
      res.status(200).json(tables);
    } catch (error) {
      console.error('Error fetching tables:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error fetching tables', details: errorMessage });
    }
  }
  // Create new table for venue
  public async createTable(req: Request, res: Response): Promise<void> {
    try {
      const { venueId } = req.params;
      const tableData = req.body;
      // Validate ID is a valid ObjectId
      if (!mongoose.Types.ObjectId.isValid(venueId)) {
        res.status(400).json({ error: 'Invalid ID format' });
        return;
      }
      const venue = await Venue.findById(venueId);
      if (!venue) {
        res.status(404).json({ error: 'Venue not found' });
        return;
      }
      // Set the venueId for the table
      tableData.venueId = venueId;
      // Create a new table document
      const table = new Table(tableData);
      // Save the table as a separate document
      const savedTable = await table.save();
      res.status(201).json(savedTable);
    } catch (error) {
      console.error('Error creating table:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: 'Error creating table', details: errorMessage });
    }
  }
}
</file>

<file path="services/restaurant-service/src/controllers/ZoneController.ts">
import { Request, Response } from 'express';
import Zone, { IZone } from '../models/Zone';
export class ZoneController {
  // Create a new zone
  public async create(req: Request, res: Response): Promise<void> {
    try {
      console.log('Creating new zone with data:', req.body);
      const zoneData = req.body;
      const zone = new Zone(zoneData);
      console.log('Saving zone to database...');
      const savedZone = await zone.save();
      console.log('Zone saved successfully:', savedZone);
      res.status(201).json(savedZone);
    } catch (error) {
      console.error('Error creating zone:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error creating zone: ${errorMessage}` });
    }
  }
  // Get all zones
  public async getAll(req: Request, res: Response): Promise<void> {
    try {
      const zones = await Zone.find()
        .populate('venueId')
        .populate('tables');
      res.status(200).json(zones);
    } catch (error) {
      console.error('Error fetching zones:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching zones: ${errorMessage}` });
    }
  }
  // Get zone by ID
  public async getById(req: Request, res: Response): Promise<void> {
    try {
      const zone = await Zone.findById(req.params.id)
        .populate('venueId')
        .populate('tables');
      if (!zone) {
        res.status(404).json({ error: 'Zone not found' });
        return;
      }
      res.status(200).json(zone);
    } catch (error) {
      console.error('Error fetching zone:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching zone: ${errorMessage}` });
    }
  }
  // Update zone
  public async update(req: Request, res: Response): Promise<void> {
    try {
      const zone = await Zone.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true }
      );
      if (!zone) {
        res.status(404).json({ error: 'Zone not found' });
        return;
      }
      res.status(200).json(zone);
    } catch (error) {
      console.error('Error updating zone:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error updating zone: ${errorMessage}` });
    }
  }
  // Delete zone
  public async delete(req: Request, res: Response): Promise<void> {
    try {
      const zone = await Zone.findByIdAndDelete(req.params.id);
      if (!zone) {
        res.status(404).json({ error: 'Zone not found' });
        return;
      }
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting zone:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error deleting zone: ${errorMessage}` });
    }
  }
  // Get zones by venue
  public async getByVenue(req: Request, res: Response): Promise<void> {
    try {
      const zones = await Zone.find({ venueId: req.params.venueId })
        .populate('tables');
      res.status(200).json(zones);
    } catch (error) {
      console.error('Error fetching zones by venue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      res.status(500).json({ error: `Error fetching zones by venue: ${errorMessage}` });
    }
  }
}
</file>

<file path="services/restaurant-service/src/models/Category.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface ICategory extends Document {
  name: string;
  description: string;
  isActive: boolean;
  order: number;
  createdAt: Date;
  updatedAt: Date;
}
const CategorySchema: Schema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  order: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true
});
export default mongoose.model<ICategory>('Category', CategorySchema);
</file>

<file path="services/restaurant-service/src/models/Modifier.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IModifier extends Document {
  name: string;
  arabicName?: string;
  description?: string;
  arabicDescription?: string;
  price: number;
  isAvailable: boolean;
  createdAt: Date;
  updatedAt: Date;
}
const ModifierSchema: Schema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  arabicName: {
    type: String,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  arabicDescription: {
    type: String,
    trim: true
  },
  price: {
    type: Number,
    required: true,
    default: 0
  },
  isAvailable: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});
export default mongoose.model<IModifier>('Modifier', ModifierSchema);
</file>

<file path="services/restaurant-service/src/models/Restaurant.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = require("mongoose");
var VenueSchema = new mongoose_1.Schema({
    name: {
        type: String,
        required: true,
        trim: true
    },
    description: {
        type: String,
        trim: true
    },
    capacity: {
        type: Number,
        required: true,
        min: 1
    },
    isActive: {
        type: Boolean,
        default: true
    }
});
var ScheduleSchema = new mongoose_1.Schema({
    dayOfWeek: {
        type: Number,
        required: true,
        min: 0,
        max: 6
    },
    openTime: {
        type: String,
        required: true
    },
    closeTime: {
        type: String,
        required: true
    },
    isHoliday: {
        type: Boolean,
        default: false
    }
});
var MenuScheduleSchema = new mongoose_1.Schema({
    dayOfWeek: {
        type: Number,
        required: true,
        min: 0,
        max: 6
    },
    openTime: {
        type: String,
        required: true
    },
    closeTime: {
        type: String,
        required: true
    },
    isAvailable: {
        type: Boolean,
        default: true
    }
});
var RestaurantSchema = new mongoose_1.Schema({
    name: { type: String, required: true },
    locations: [{
            address: { type: String, required: true },
            coordinates: {
                latitude: { type: Number, required: true },
                longitude: { type: Number, required: true }
            }
        }],
    venues: { type: [mongoose_1.Schema.Types.ObjectId], ref: 'Venue', default: [] },
    tables: { type: [mongoose_1.Schema.Types.ObjectId], ref: 'Table', default: [] },
    menu: [{
            category: { type: String, required: true },
            items: [{
                    name: { type: String, required: true },
                    description: { type: String },
                    price: { type: Number, required: true },
                    modifiers: [{
                            name: { type: String, required: true },
                            options: [{ type: String }],
                            price: { type: Number, required: true }
                        }],
                    isAvailable: { type: Boolean, default: true },
                    schedule: [MenuScheduleSchema]
                }]
        }],
    schedule: [ScheduleSchema],
    adminIds: [{ type: mongoose_1.Schema.Types.ObjectId, ref: 'User' }]
}, {
    timestamps: true
});
exports.default = mongoose_1.default.model('Restaurant', RestaurantSchema);
</file>

<file path="services/restaurant-service/src/models/Restaurant.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IVenue extends Document {
  name: string;
  description?: string;
  capacity: number;
  isActive: boolean;
}
export interface ISchedule extends Document {
  dayOfWeek: number;
  openTime: string;
  closeTime: string;
  isHoliday: boolean;
}
export interface IMenuSchedule extends Document {
  dayOfWeek: number;
  openTime: string;
  closeTime: string;
  isAvailable: boolean;
}
export interface IRestaurant extends Document {
  name: string;
  locations: Array<{
    address: string;
    coordinates: {
      latitude: number;
      longitude: number;
    };
  }>;
  venues: mongoose.Types.ObjectId[];
  tables: mongoose.Types.ObjectId[];
  menu: Array<{
    category: string;
    items: Array<{
      name: string;
      description: string;
      price: number;
      modifiers: Array<{
        name: string;
        options: string[];
        price: number;
      }>;
      isAvailable: boolean;
      schedule: IMenuSchedule[];
    }>;
  }>;
  adminIds: string[];
  schedule: ISchedule[];
  createdAt: Date;
  updatedAt: Date;
}
const VenueSchema: Schema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  capacity: {
    type: Number,
    required: true,
    min: 1
  },
  isActive: {
    type: Boolean,
    default: true
  }
});
const ScheduleSchema: Schema = new Schema({
  dayOfWeek: {
    type: Number,
    required: true,
    min: 0,
    max: 6
  },
  openTime: {
    type: String,
    required: true
  },
  closeTime: {
    type: String,
    required: true
  },
  isHoliday: {
    type: Boolean,
    default: false
  }
});
const MenuScheduleSchema: Schema = new Schema({
  dayOfWeek: {
    type: Number,
    required: true,
    min: 0,
    max: 6
  },
  openTime: {
    type: String,
    required: true
  },
  closeTime: {
    type: String,
    required: true
  },
  isAvailable: {
    type: Boolean,
    default: true
  }
});
const RestaurantSchema: Schema = new Schema({
  name: { type: String, required: true },
  locations: [{
    address: { type: String, required: true },
    coordinates: {
      latitude: { type: Number, required: true },
      longitude: { type: Number, required: true }
    }
  }],
  venues: { type: [Schema.Types.ObjectId], ref: 'Venue', default: [] },
  tables: { type: [Schema.Types.ObjectId], ref: 'Table', default: [] },
  menu: [{
    category: { type: String, required: true },
    items: [{
      name: { type: String, required: true },
      description: { type: String },
      price: { type: Number, required: true },
      modifiers: [{
        name: { type: String, required: true },
        options: [{ type: String }],
        price: { type: Number, required: true }
      }],
      isAvailable: { type: Boolean, default: true },
      schedule: [MenuScheduleSchema]
    }]
  }],
  schedule: [ScheduleSchema],
  adminIds: [{ type: Schema.Types.ObjectId, ref: 'User' }]
}, {
  timestamps: true
});
export default mongoose.model<IRestaurant>('Restaurant', RestaurantSchema);
</file>

<file path="services/restaurant-service/src/models/Table.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = require("mongoose");
var TableSchema = new mongoose_1.Schema({
    number: {
        type: String,
        required: true
    },
    venueId: {
        type: mongoose_1.default.Schema.Types.ObjectId,
        required: true,
        ref: 'Venue'
    },
    capacity: {
        type: Number,
        required: true,
        min: 1
    },
    type: {
        type: String,
        required: true,
        enum: ['REGULAR', 'VIP', 'COUNTER', 'LOUNGE']
    },
    qrCode: {
        type: String,
        sparse: true
    },
    isOccupied: {
        type: Boolean,
        default: false
    },
    isActive: {
        type: Boolean,
        default: true
    },
    menuId: {
        type: mongoose_1.default.Schema.Types.ObjectId,
        ref: 'Menu',
        required: false
    }
}, {
    timestamps: true
});
exports.default = mongoose_1.default.model('Table', TableSchema);
</file>

<file path="services/restaurant-service/src/models/Table.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface ITable extends Document {
  number: string;
  venueId: mongoose.Types.ObjectId;
  capacity: number;
  type: string;
  qrCode: string;
  isOccupied: boolean;
  isActive: boolean;
  menuId?: mongoose.Types.ObjectId;
}
const TableSchema: Schema = new Schema({
  number: {
    type: String,
    required: true
  },
  venueId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Venue'
  },
  capacity: {
    type: Number,
    required: true,
    min: 1
  },
  type: {
    type: String,
    required: true,
    enum: ['REGULAR', 'VIP', 'COUNTER', 'LOUNGE']
  },
  qrCode: {
    type: String,
    sparse: true
  },
  isOccupied: {
    type: Boolean,
    default: false
  },
  isActive: {
    type: Boolean,
    default: true
  },
  menuId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Menu',
    required: false
  }
}, {
  timestamps: true
});
export default mongoose.model<ITable>('Table', TableSchema);
</file>

<file path="services/restaurant-service/src/models/Venue.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IVenue extends Document {
  name: string;
  description?: string;
  capacity: number;
  isActive: boolean;
  restaurantId: mongoose.Types.ObjectId;
}
const VenueSchema: Schema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  capacity: {
    type: Number,
    required: true,
    min: 1
  },
  isActive: {
    type: Boolean,
    default: true
  },
  restaurantId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    ref: 'Restaurant'
  }
}, {
  timestamps: true
});
export default mongoose.model<IVenue>('Venue', VenueSchema);
</file>

<file path="services/restaurant-service/src/models/Zone.ts">
import mongoose, { Schema, Document } from 'mongoose';
export interface IZone extends Document {
  name: string;
  description?: string;
  venueId: mongoose.Types.ObjectId;
  capacity: number;
  isActive: boolean;
  tables: mongoose.Types.ObjectId[];
}
const ZoneSchema: Schema = new Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  venueId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Venue',
    required: true
  },
  capacity: {
    type: Number,
    required: true,
    min: 0
  },
  isActive: {
    type: Boolean,
    default: true
  },
  tables: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Table'
  }]
}, {
  timestamps: true
});
export default mongoose.model<IZone>('Zone', ZoneSchema);
</file>

<file path="services/restaurant-service/src/routes/category.routes.ts">
import { Router } from 'express';
import { CategoryController } from '../controllers/CategoryController';
const router = Router();
const categoryController = new CategoryController();
// Get all categories
router.get('/', categoryController.getAll);
// Get a single category by ID
router.get('/:id', categoryController.getById);
// Create a new category
router.post('/', categoryController.create);
// Update a category
router.put('/:id', categoryController.update);
// Delete a category
router.delete('/:id', categoryController.delete);
// Toggle category availability
router.patch('/:id/toggle-availability', categoryController.toggleAvailability);
export default router;
</file>

<file path="services/restaurant-service/src/routes/menu.routes.ts">
import { Router } from 'express';
import { MenuController } from '../controllers/MenuController';
const router = Router();
const controller = new MenuController();
// Menu routes
router.post('/', controller.create);
router.get('/', controller.getAll);
router.get('/:id', controller.getById);
router.put('/:id', controller.update);
router.delete('/:id', controller.delete);
// Menu category routes
router.post('/:menuId/categories', controller.addCategory);
router.get('/:menuId/categories', controller.getCategories);
router.put('/:menuId/categories/:categoryId', controller.updateCategory);
router.delete('/:menuId/categories/:categoryId', controller.deleteCategory);
// Menu item routes
router.post('/:menuId/categories/:categoryId/items', controller.addMenuItem);
router.put('/:menuId/categories/:categoryId/items/:itemId', controller.updateMenuItem);
router.delete('/:menuId/categories/:categoryId/items/:itemId', controller.deleteMenuItem);
router.patch('/:menuId/categories/:categoryId/items/:itemId/availability', controller.updateItemAvailability);
export default router;
</file>

<file path="services/restaurant-service/src/routes/modifier.routes.ts">
import { Router } from 'express';
import { ModifierController } from '../controllers/ModifierController';
const router = Router();
const modifierController = new ModifierController();
// Get all modifiers
router.get('/', modifierController.getAll);
// Get a single modifier by ID
router.get('/:id', modifierController.getById);
// Create a new modifier
router.post('/', modifierController.create);
// Update a modifier
router.put('/:id', modifierController.update);
// Delete a modifier
router.delete('/:id', modifierController.delete);
// Toggle modifier availability
router.patch('/:id/toggle-availability', modifierController.toggleAvailability);
export default router;
</file>

<file path="services/restaurant-service/src/routes/restaurant.routes.ts">
import { Router } from 'express';
import { RestaurantController } from '../controllers/RestaurantController';
/**
 * @swagger
 * tags:
 *   name: Restaurants
 *   description: Restaurant management endpoints
 */
const router = Router();
const controller = new RestaurantController();
/**
 * @swagger
 * /:
 *   post:
 *     tags: [Restaurants]
 *     summary: Create a new restaurant
 *   get:
 *     tags: [Restaurants]
 *     summary: Get all restaurants
 */
router.post('/', controller.create.bind(controller));
router.get('/', controller.getAll.bind(controller));
/**
 * @swagger
 * /{id}:
 *   get:
 *     tags: [Restaurants]
 *     summary: Get a restaurant by ID
 *   put:
 *     tags: [Restaurants]
 *     summary: Update a restaurant
 *   delete:
 *     tags: [Restaurants]
 *     summary: Delete a restaurant
 */
router.get('/:id', controller.getById.bind(controller));
router.put('/:id', controller.update.bind(controller));
router.delete('/:id', controller.delete.bind(controller));
/**
 * @swagger
 * /{restaurantId}/venues:
 *   get:
 *     tags: [Restaurants]
 *     summary: Get all venues for a restaurant
 */
router.get('/:restaurantId/venues', controller.getVenues.bind(controller));
/**
 * @swagger
 * /restaurants/{id}/menu-categories:
 *   post:
 *     tags: [Restaurants]
 *     summary: Add a menu category to a restaurant
 */
router.post('/:id/menu-categories', controller.addMenuCategory.bind(controller));
/**
 * @swagger
 * /restaurants/{id}/menu-items:
 *   post:
 *     tags: [Restaurants]
 *     summary: Add a menu item to a restaurant
 */
router.post('/:id/menu-items', controller.addMenuItem.bind(controller));
/**
 * @swagger
 * /restaurants/{id}/table-status:
 *   put:
 *     tags: [Restaurants]
 *     summary: Update table status for a restaurant
 */
router.put('/:id/table-status', controller.updateTableStatus.bind(controller));
export default router;
</file>

<file path="services/restaurant-service/src/routes/table.routes.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var express_1 = require("express");
var TableController_1 = require("../controllers/TableController");
var router = (0, express_1.Router)();
var controller = new TableController_1.TableController();
// Debug middleware
var debugMiddleware = function (req, res, next) {
    console.log('Table Route:', {
        method: req.method,
        path: req.path,
        url: req.url,
        baseUrl: req.baseUrl,
        originalUrl: req.originalUrl,
        params: req.params,
        body: req.body
    });
    next();
};
// Validation middleware
var validateIds = function (req, res, next) {
    var _a = req.params, restaurantId = _a.restaurantId, venueId = _a.venueId, tableId = _a.tableId;
    if (restaurantId && !(/^[0-9a-fA-F]{24}$/).test(restaurantId)) {
        res.status(400).json({ error: 'Invalid restaurant ID format' });
        return;
    }
    if (venueId && !(/^[0-9a-fA-F]{24}$/).test(venueId)) {
        res.status(400).json({ error: 'Invalid venue ID format' });
        return;
    }
    if (tableId && !(/^[0-9a-fA-F]{24}$/).test(tableId)) {
        res.status(400).json({ error: 'Invalid table ID format' });
        return;
    }
    next();
};
// Body validation middleware
var validateTableBody = function (req, res, next) {
    var _a = req.body, number = _a.number, capacity = _a.capacity, type = _a.type;
    if (!number || typeof number !== 'string') {
        res.status(400).json({ error: 'Table number is required and must be a string' });
        return;
    }
    // Convert capacity to number if it's a string
    var capacityNum = typeof capacity === 'string' ? parseInt(capacity, 10) : capacity;
    if (!capacityNum || typeof capacityNum !== 'number' || capacityNum <= 0 || isNaN(capacityNum)) {
        res.status(400).json({ error: 'Capacity is required and must be a positive number' });
        return;
    }
    // Update the body with the converted capacity
    req.body.capacity = capacityNum;
    if (!type || typeof type !== 'string' || !['REGULAR', 'VIP', 'COUNTER', 'LOUNGE'].includes(type)) {
        res.status(400).json({ error: 'Table type is required and must be one of: REGULAR, VIP, COUNTER, LOUNGE' });
        return;
    }
    next();
};
// Apply debug middleware to all routes
router.use(debugMiddleware);
// Table CRUD routes
router.route('/restaurant/:restaurantId/venue/:venueId')
    .post(validateIds, validateTableBody, controller.create.bind(controller));
router.route('/restaurant/:restaurantId/venue/:venueId/tables')
    .get(validateIds, controller.getAll.bind(controller));
router.route('/restaurant/:restaurantId/venue/:venueId/tables/:tableId')
    .get(validateIds, controller.getById.bind(controller))
    .put(validateIds, validateTableBody, controller.update.bind(controller))
    .delete(validateIds, controller.delete.bind(controller));
// Table QR code routes
router.route('/restaurant/:restaurantId/venue/:venueId/tables/:tableId/qrcode')
    .post(validateIds, controller.generateQRCode.bind(controller))
    .get(validateIds, controller.getQRCode.bind(controller))
    .delete(validateIds, controller.deleteQRCode.bind(controller));
exports.default = router;
</file>

<file path="services/restaurant-service/src/routes/table.routes.ts">
import { Router, Request, Response, NextFunction } from 'express';
import { TableController } from '../controllers/TableController';
const router = Router();
const controller = new TableController();
// Debug middleware
const debugMiddleware = (req: Request, res: Response, next: NextFunction): void => {
  console.log('Table Route:', {
    method: req.method,
    path: req.path,
    url: req.url,
    baseUrl: req.baseUrl,
    originalUrl: req.originalUrl,
    params: req.params,
    body: req.body
  });
  next();
};
// Validation middleware
const validateIds = (req: Request, res: Response, next: NextFunction): void => {
  const { restaurantId, venueId, tableId } = req.params;
  if (restaurantId && !(/^[0-9a-fA-F]{24}$/).test(restaurantId)) {
    res.status(400).json({ error: 'Invalid restaurant ID format' });
    return;
  }
  if (venueId && !(/^[0-9a-fA-F]{24}$/).test(venueId)) {
    res.status(400).json({ error: 'Invalid venue ID format' });
    return;
  }
  if (tableId && !(/^[0-9a-fA-F]{24}$/).test(tableId)) {
    res.status(400).json({ error: 'Invalid table ID format' });
    return;
  }
  next();
};
// Body validation middleware
const validateTableBody = (req: Request, res: Response, next: NextFunction): void => {
  const { number, capacity, type } = req.body;
  if (!number || typeof number !== 'string') {
    res.status(400).json({ error: 'Table number is required and must be a string' });
    return;
  }
  // Convert capacity to number if it's a string
  const capacityNum = typeof capacity === 'string' ? parseInt(capacity, 10) : capacity;
  if (!capacityNum || typeof capacityNum !== 'number' || capacityNum <= 0 || isNaN(capacityNum)) {
    res.status(400).json({ error: 'Capacity is required and must be a positive number' });
    return;
  }
  // Update the body with the converted capacity
  req.body.capacity = capacityNum;
  if (!type || typeof type !== 'string' || !['REGULAR', 'VIP', 'COUNTER', 'LOUNGE'].includes(type)) {
    res.status(400).json({ error: 'Table type is required and must be one of: REGULAR, VIP, COUNTER, LOUNGE' });
    return;
  }
  next();
};
// Apply debug middleware to all routes
router.use(debugMiddleware);
// Table CRUD routes
router.route('/restaurant/:restaurantId/venue/:venueId')
  .post(validateIds, validateTableBody, controller.create.bind(controller));
router.route('/restaurant/:restaurantId/venue/:venueId/tables')
  .get(validateIds, controller.getAll.bind(controller));
router.route('/restaurant/:restaurantId/venue/:venueId/tables/:tableId')
  .get(validateIds, controller.getById.bind(controller))
  .put(validateIds, validateTableBody, controller.update.bind(controller))
  .delete(validateIds, controller.delete.bind(controller));
// Table QR code routes
router.route('/restaurant/:restaurantId/venue/:venueId/tables/:tableId/qrcode')
  .post(validateIds, controller.generateQRCode.bind(controller))
  .get(validateIds, controller.getQRCode.bind(controller))
  .delete(validateIds, controller.deleteQRCode.bind(controller));
export default router;
</file>

<file path="services/restaurant-service/src/routes/venue.routes.ts">
import { Router } from 'express';
import { Request, Response, NextFunction } from 'express';
import { VenueController } from '../controllers/VenueController';
const router = Router();
const controller = new VenueController();
// Debug middleware
const debugMiddleware = (req: Request, res: Response, next: NextFunction) => {
  console.log('Venue Route:', {
    method: req.method,
    path: req.path,
    url: req.url,
    baseUrl: req.baseUrl,
    originalUrl: req.originalUrl,
    params: req.params,
    body: req.body
  });
  next();
};
// Apply debug middleware
router.use(debugMiddleware);
// Get all venues (global)
router.get('/venues', controller.getAllVenues);
// Restaurant-specific venue routes
router.post('/venues/restaurant/:restaurantId', controller.create);
router.get('/venues/restaurant/:restaurantId', controller.getAll);
// Individual venue routes
router.get('/venues/:id', controller.getById);
router.put('/venues/:id', controller.update);
router.delete('/venues/:id', controller.delete);
// Venue tables routes
router.get('/venues/:venueId/tables', controller.getTables);
router.post('/venues/:venueId/tables', controller.createTable);
export default router;
</file>

<file path="services/restaurant-service/src/routes/zone.routes.ts">
import { Router } from 'express';
import { ZoneController } from '../controllers/ZoneController';
const router = Router();
const controller = new ZoneController();
// Create a new zone
router.post('/', (req, res) => controller.create(req, res));
// Get all zones
router.get('/', (req, res) => controller.getAll(req, res));
// Get zone by ID
router.get('/:id', (req, res) => controller.getById(req, res));
// Update zone
router.put('/:id', (req, res) => controller.update(req, res));
// Delete zone
router.delete('/:id', (req, res) => controller.delete(req, res));
// Get zones by venue
router.get('/venue/:venueId', (req, res) => controller.getByVenue(req, res));
export default router;
</file>

<file path="services/restaurant-service/src/tests/restaurant.test.ts">
// @ts-nocheck
import request from 'supertest';
import mongoose from 'mongoose';
import { app } from '../app';
import Restaurant, { ITable } from '../../../restaurant-service/src/models/Restaurant';
import Menu from '../models/menu.model';
describe('Restaurant Service API Tests', () => {
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/restaurant-test');
  });
  afterAll(async () => {
    await mongoose.connection.dropDatabase();
    await mongoose.connection.close();
  });
  beforeEach(async () => {
    await Restaurant.deleteMany({});
    await Menu.deleteMany({});
  });
  describe('Restaurant Endpoints', () => {
    const testRestaurant = {
      name: 'Test Restaurant',
      description: 'A test restaurant',
      address: {
        street: '123 Test St',
        city: 'Test City',
        state: 'TS',
        country: 'Test Country',
        postalCode: '12345'
      },
      contact: {
        phone: '123-456-7890',
        email: 'test@test.com',
        website: 'www.test.com'
      },
      cuisine: ['Test Cuisine'],
      priceRange: '$$',
      features: ['Test Feature']
    };
    test('POST /api/restaurants - Create restaurant', async () => {
      const response = await request(app)
        .post('/api/restaurants')
        .send(testRestaurant);
      expect(response.status).toBe(201);
      expect(response.body.name).toBe(testRestaurant.name);
    });
    test('GET /api/restaurants - Get all restaurants', async () => {
      await Restaurant.create(testRestaurant);
      const response = await request(app)
        .get('/api/restaurants');
      expect(response.status).toBe(200);
      expect(response.body.length).toBe(1);
      expect(response.body[0].name).toBe(testRestaurant.name);
    });
  });
  describe('Venue Endpoints', () => {
    let restaurantId: string;
    const testVenue = {
      name: 'Test Venue',
      description: 'A test venue',
      capacity: 100
    };
    beforeEach(async () => {
      const restaurant = await Restaurant.create({
        name: 'Test Restaurant',
        description: 'A test restaurant'
      });
      restaurantId = restaurant._id.toString();
    });
    test('POST /api/venues - Create venue', async () => {
      const response = await request(app)
        .post(`/api/restaurants/${restaurantId}/venues`)
        .send(testVenue);
      expect(response.status).toBe(201);
      expect(response.body.name).toBe(testVenue.name);
    });
    test('GET /api/venues - Get all venues', async () => {
      await request(app)
        .post(`/api/restaurants/${restaurantId}/venues`)
        .send(testVenue);
      const response = await request(app)
        .get(`/api/restaurants/${restaurantId}/venues`);
      expect(response.status).toBe(200);
      expect(response.body.length).toBe(1);
      expect(response.body[0].name).toBe(testVenue.name);
    });
  });
  describe('Table Endpoints', () => {
    let restaurantId: string;
    let venueId: string;
    const testTable = {
      number: 'T1',
      capacity: 4,
      type: 'REGULAR'
    };
    beforeEach(async () => {
      const restaurant = await Restaurant.create({
        name: 'Test Restaurant',
        venues: [{
          name: 'Test Venue',
          capacity: 100
        }]
      });
      restaurantId = restaurant._id.toString();
      venueId = restaurant.venues[0]._id.toString();
    });
    test('POST /api/tables - Create table', async () => {
      const response = await request(app)
        .post(`/api/restaurants/${restaurantId}/venues/${venueId}/tables`)
        .send(testTable);
      expect(response.status).toBe(201);
      expect(response.body.number).toBe(testTable.number);
    });
    test('GET /api/tables - Get all tables', async () => {
      await request(app)
        .post(`/api/restaurants/${restaurantId}/venues/${venueId}/tables`)
        .send(testTable);
      const response = await request(app)
        .get(`/api/restaurants/${restaurantId}/venues/${venueId}/tables`);
      expect(response.status).toBe(200);
      expect(response.body.length).toBe(1);
      expect(response.body[0].number).toBe(testTable.number);
    });
  });
  describe('Menu Endpoints', () => {
    let restaurantId: string;
    const testMenu = {
      name: 'Test Menu',
      categories: [{
        name: 'Test Category',
        items: [{
          name: 'Test Item',
          description: 'A test item',
          price: 9.99,
          category: 'Test Category'
        }]
      }]
    };
    beforeEach(async () => {
      const restaurant = await Restaurant.create({
        name: 'Test Restaurant'
      });
      restaurantId = restaurant._id.toString();
    });
    test('POST /api/menus - Create menu', async () => {
      const response = await request(app)
        .post(`/api/restaurants/${restaurantId}/menus`)
        .send(testMenu);
      expect(response.status).toBe(201);
      expect(response.body.name).toBe(testMenu.name);
    });
    test('GET /api/menus - Get all menus', async () => {
      await request(app)
        .post(`/api/restaurants/${restaurantId}/menus`)
        .send(testMenu);
      const response = await request(app)
        .get(`/api/restaurants/${restaurantId}/menus`);
      expect(response.status).toBe(200);
      expect(response.body.length).toBe(1);
      expect(response.body[0].name).toBe(testMenu.name);
    });
  });
  describe('QR Code Endpoints', () => {
    let restaurantId: string;
    let venueId: string;
    let tableId: string;
    beforeEach(async () => {
      const restaurant = await Restaurant.create({
        name: 'Test Restaurant',
        venues: [{
          name: 'Test Venue',
          capacity: 100,
          tables: [{
            number: 'T1',
            capacity: 4,
            type: 'REGULAR'
          }]
        }]
      });
      restaurantId = restaurant._id.toString();
      venueId = restaurant.venues[0]._id.toString();
      tableId = restaurant.venues[0].tables[0]._id.toString();
    });
    test('POST /api/tables/:tableId/qrcode - Generate QR code', async () => {
      const response = await request(app)
        .post(`/api/restaurants/${restaurantId}/venues/${venueId}/tables/${tableId}/qrcode`);
      expect(response.status).toBe(201);
      expect(response.body.qrCode).toBeDefined();
    });
    test('GET /api/tables/:tableId/qrcode - Get QR code', async () => {
      await request(app)
        .post(`/api/restaurants/${restaurantId}/venues/${venueId}/tables/${tableId}/qrcode`);
      const response = await request(app)
        .get(`/api/restaurants/${restaurantId}/venues/${venueId}/tables/${tableId}/qrcode`);
      expect(response.status).toBe(200);
      expect(response.body.qrCode).toBeDefined();
    });
  });
});
</file>

<file path="services/restaurant-service/src/app.ts">
// import express from 'express';
// import cors from 'cors';
// import mongoose from 'mongoose';
// import restaurantRoutes from './routes/restaurant.routes';
// import venueRoutes from './routes/venue.routes';
// import tableRoutes from './routes/table.routes';
// import menuRoutes from './routes/menu.routes';
// export const app = express();
// app.use(cors());
// app.use(express.json());
// // Connect to MongoDB
// mongoose.connect('mongodb://localhost:27017/inseat')
//   .then(() => console.log('Connected to MongoDB'))
//   .catch(err => console.error('MongoDB connection error:', err));
// // Debug middleware
// app.use((req, res, next) => {
//   console.log('Request:', {
//     method: req.method,
//     url: req.url,
//     body: req.body,
//     params: req.params
//   });
//   next();
// });
// // Routes
// app.use('/api', tableRoutes);
// app.use('/api/restaurants', restaurantRoutes);
// app.use('/api/venues', venueRoutes);
// app.use('/api/menus', menuRoutes);
// // Debug middleware
// app.use((req, res, next) => {
//   console.log('Request:', {
//     method: req.method,
//     url: req.url,
//     body: req.body,
//     params: req.params
//   });
//   next();
// });
// // Error handling middleware
// app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
//   console.error('Error:', err);
//   res.status(err.status || 500).json({
//     error: err.message || 'Internal Server Error'
//   });
// });
// // Start server
// const PORT = process.env.PORT || 5173;
// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });
// export default app;
</file>

<file path="services/restaurant-service/test-commands.sh">
#!/bin/bash
# Base URL
BASE_URL="http://localhost:3000/api"
# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'
echo -e "${GREEN}Testing Restaurant Management API${NC}\n"
# Create a restaurant
echo "Creating a restaurant..."
RESTAURANT_RESPONSE=$(curl -s -X POST "$BASE_URL/restaurants" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Sample Restaurant",
    "description": "A sample restaurant for testing",
    "address": {
      "street": "123 Test St",
      "city": "Test City",
      "state": "TS",
      "country": "Test Country",
      "postalCode": "12345"
    },
    "contact": {
      "phone": "123-456-7890",
      "email": "test@test.com",
      "website": "www.test.com"
    },
    "cuisine": ["Italian", "Mediterranean"],
    "priceRange": "$$",
    "features": ["Outdoor Seating", "Wi-Fi"]
  }')
RESTAURANT_ID=$(echo $RESTAURANT_RESPONSE | jq -r '._id')
echo -e "Restaurant created with ID: ${GREEN}$RESTAURANT_ID${NC}\n"
# Create a venue
echo "Creating a venue..."
VENUE_RESPONSE=$(curl -s -X POST "$BASE_URL/restaurants/$RESTAURANT_ID/venues" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Main Dining Hall",
    "description": "Main indoor dining area",
    "capacity": 100
  }')
VENUE_ID=$(echo $VENUE_RESPONSE | jq -r '._id')
echo -e "Venue created with ID: ${GREEN}$VENUE_ID${NC}\n"
# Create a table
echo "Creating a table..."
TABLE_RESPONSE=$(curl -s -X POST "$BASE_URL/restaurants/$RESTAURANT_ID/venues/$VENUE_ID/tables" \
  -H "Content-Type: application/json" \
  -d '{
    "number": "T1",
    "capacity": 4,
    "type": "REGULAR"
  }')
TABLE_ID=$(echo $TABLE_RESPONSE | jq -r '._id')
echo -e "Table created with ID: ${GREEN}$TABLE_ID${NC}\n"
# Create a menu
echo "Creating a menu..."
MENU_RESPONSE=$(curl -s -X POST "$BASE_URL/restaurants/$RESTAURANT_ID/menus" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Lunch Menu",
    "categories": [{
      "name": "Appetizers",
      "items": [{
        "name": "Bruschetta",
        "description": "Toasted bread with tomatoes and herbs",
        "price": 8.99,
        "category": "Appetizers",
        "preparationTime": 10,
        "isAvailable": true,
        "allergens": ["gluten"]
      }]
    }]
  }')
MENU_ID=$(echo $MENU_RESPONSE | jq -r '._id')
echo -e "Menu created with ID: ${GREEN}$MENU_ID${NC}\n"
# Generate QR code for table
echo "Generating QR code for table..."
curl -s -X POST "$BASE_URL/restaurants/$RESTAURANT_ID/venues/$VENUE_ID/tables/$TABLE_ID/qrcode"
echo -e "\nQR code generated\n"
# Assign menu to table
echo "Assigning menu to table..."
curl -s -X POST "$BASE_URL/restaurants/$RESTAURANT_ID/venues/$VENUE_ID/tables/$TABLE_ID/menus/$MENU_ID"
echo -e "\nMenu assigned to table\n"
# Get all data
echo -e "\n${GREEN}Getting all data...${NC}"
echo -e "\n${GREEN}Restaurants:${NC}"
curl -s "$BASE_URL/restaurants" | jq '.'
echo -e "\n${GREEN}Venues:${NC}"
curl -s "$BASE_URL/restaurants/$RESTAURANT_ID/venues" | jq '.'
echo -e "\n${GREEN}Tables:${NC}"
curl -s "$BASE_URL/restaurants/$RESTAURANT_ID/venues/$VENUE_ID/tables" | jq '.'
echo -e "\n${GREEN}Menus:${NC}"
curl -s "$BASE_URL/restaurants/$RESTAURANT_ID/menus" | jq '.'
echo -e "\n${GREEN}Table QR Code:${NC}"
curl -s "$BASE_URL/restaurants/$RESTAURANT_ID/venues/$VENUE_ID/tables/$TABLE_ID/qrcode" | jq '.'
</file>

<file path="services/restaurant-service/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "../auth-service"]
}
</file>

<file path="services/index.ts">
import { Router } from 'express';
import restaurantRoutes from './restaurant-service/src/routes/restaurant.routes';
import tableRoutes from './restaurant-service/src/routes/table.routes';
import venueRoutes from './restaurant-service/src/routes/venue.routes';
import menuRoutes from './restaurant-service/src/routes/menu.routes';
import zoneRoutes from './restaurant-service/src/routes/zone.routes';
import categoryRoutes from './restaurant-service/src/routes/category.routes';
import modifierRoutes from './restaurant-service/src/routes/modifier.routes';
import orderRoutes from './order-service/src/routes/orderRoutes';
import authRoutes from './auth-service/src/routes/authRoutes';
import roleRoutes from './auth-service/src/routes/roleRoutes';
import permissionRoutes from './auth-service/src/routes/permissionRoutes';
const router = Router();
router.use('/restaurants', restaurantRoutes);
router.use('/tables', tableRoutes);
router.use('/venues', venueRoutes);
router.use('/menus', menuRoutes);
router.use('/zones', zoneRoutes);
router.use('/categories', categoryRoutes);
router.use('/modifiers', modifierRoutes);
router.use('/orders', orderRoutes);
router.use('/auth', authRoutes);
router.use('/auth/roles', roleRoutes);
router.use('/auth/permissions', permissionRoutes);
export default router;
</file>

<file path="src/config/websocket.ts">
import { Server as HTTPServer } from 'http';
import { WebSocket, Server as WebSocketServer } from 'ws';
// Import Order model and interface from the correct path
import OrderModel, { IOrder } from '../../services/order-service/src/models/Order';
// Define a type alias for better readability
type Order = IOrder;
interface ExtendedWebSocket extends WebSocket {
  isAlive: boolean;
  userId?: string;
  userRole?: string;
}
export class WebSocketManager {
  private static instance: WebSocketManager;
  private wss: WebSocketServer;
  private clients: Map<string, ExtendedWebSocket>;
  private pingInterval: NodeJS.Timeout;
  private constructor(server: HTTPServer) {
    this.wss = new WebSocketServer({ server });
    this.clients = new Map();
    this.setupWebSocket();
    this.pingInterval = this.startPingInterval();
  }
  private setupWebSocket(): void {
    this.wss.on('connection', async (ws: WebSocket, request) => {
      const extWs = ws as ExtendedWebSocket;
      try {
        // Set up client properties
        extWs.isAlive = true;
        this.clients.set(request.headers['sec-websocket-key'] as string, extWs);
        console.log(`Client connected: ${request.headers['sec-websocket-key']}`);
        // Set up ping-pong
        extWs.on('pong', () => {
          extWs.isAlive = true;
        });
        // Handle messages
        extWs.on('message', (data: string) => {
          console.log('Received:', data);
        });
        // Handle client disconnect
        extWs.on('close', () => {
          this.clients.delete(request.headers['sec-websocket-key'] as string);
          console.log(`Client disconnected: ${request.headers['sec-websocket-key']}`);
        });
        // Send initial connection success message
        extWs.send(JSON.stringify({
          type: 'CONNECTION_ESTABLISHED',
          message: 'Successfully connected to WebSocket server',
          timestamp: Date.now()
        }));
      } catch (error) {
        console.error('WebSocket connection error:', error);
        extWs.close();
      }
    });
  }
  private startPingInterval(): NodeJS.Timeout {
    return setInterval(() => {
      this.wss.clients.forEach((ws: WebSocket) => {
        const extWs = ws as ExtendedWebSocket;
        if (!extWs.isAlive) {
          return ws.terminate();
        }
        extWs.isAlive = false;
        ws.ping();
      });
    }, 30000);
  }
  public static initialize(server: HTTPServer): WebSocketManager {
    if (!WebSocketManager.instance) {
      WebSocketManager.instance = new WebSocketManager(server);
    }
    return WebSocketManager.instance;
  }
  public static getInstance(): WebSocketManager {
    if (!WebSocketManager.instance) {
      throw new Error('WebSocketManager not initialized');
    }
    return WebSocketManager.instance;
  }
  public notifyNewOrder(order: Order): void {
    this.broadcast({
      type: 'NEW_ORDER',
      data: order,
      timestamp: Date.now()
    });
  }
  public notifyOrderUpdate(order: Order): void {
    this.broadcast({
      type: 'ORDER_UPDATE',
      data: order,
      timestamp: Date.now()
    });
  }
  public sendOrderAlert(alertData: any): void {
    this.broadcast({
      type: 'ORDER_ALERT',
      data: alertData,
      timestamp: Date.now()
    });
  }
  private broadcast(message: any): void {
    this.wss.clients.forEach((ws: WebSocket) => {
      const extWs = ws as ExtendedWebSocket;
      if (extWs.readyState === WebSocket.OPEN) {
        extWs.send(JSON.stringify(message));
      }
    });
  }
  public cleanup(): void {
    clearInterval(this.pingInterval);
    this.wss.close();
  }
}
export const getWebSocketManager = (): WebSocketManager => {
  return WebSocketManager.getInstance();
};
</file>

<file path="src/services/LiveOrderMonitor.ts">
// import { Order } from '../models/Order';
import Order from '../../services/order-service/src/models/Order';
import { getWebSocketManager } from '../config/websocket';
export class LiveOrderMonitor {
  private checkInterval: NodeJS.Timeout | null = null;
  private static instance: LiveOrderMonitor;
  private constructor() {
    // Private constructor for singleton
  }
  static getInstance(): LiveOrderMonitor {
    if (!LiveOrderMonitor.instance) {
      LiveOrderMonitor.instance = new LiveOrderMonitor();
    }
    return LiveOrderMonitor.instance;
  }
  start(intervalMs: number = 10000) { // Check every 10 seconds by default
    if (this.checkInterval) {
      return;
    }
    this.checkInterval = setInterval(async () => {
      try {
        // Get all active orders
        const activeOrders = await Order.find({
          status: { 
            $in: ['PENDING', 'CONFIRMED', 'IN_PREPARATION', 'READY_FOR_PICKUP'] 
          }
        });
        // Check for orders that need attention (e.g., pending too long)
        const now = new Date();
        activeOrders.forEach(order => {
          const orderAge = now.getTime() - order.createdAt.getTime();
          // Alert if order is pending for more than 5 minutes
          if (order.status === 'PENDING' && orderAge > 5 * 60 * 1000) {
            getWebSocketManager().sendOrderAlert({
              orderId: order._id,
              message: 'Order pending for more than 5 minutes',
              age: orderAge
            });
          }
          // Alert if order is in preparation for more than 30 minutes
          if (order.status === 'IN_PREPARATION' && orderAge > 30 * 60 * 1000) {
            getWebSocketManager().sendOrderAlert({
              orderId: order._id,
              message: 'Order in preparation for more than 30 minutes',
              age: orderAge
            });
          }
        });
      } catch (error) {
        console.error('Error in LiveOrderMonitor:', error);
      }
    }, intervalMs);
  }
  stop() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }
}
</file>

<file path="src/app.ts">
import express from 'express';
import http from 'http';
import mongoose from 'mongoose';
import cors from 'cors';
import { WebSocketManager } from './config/websocket';
import { LiveOrderMonitor } from './services/LiveOrderMonitor';
import apiRoutes from '../services/index';
import events from 'events';
// Increase max listeners to avoid memory leak warning
events.defaultMaxListeners = 20;
const app = express();
const server = http.createServer(app);
// Initialize WebSocket
WebSocketManager.initialize(server);
// Middleware
app.use(cors());
app.use(express.json());
app.disable('x-powered-by');
// Connect to MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/inseat')
  .then(() => console.log('Connected to MongoDB'))
  .catch((err) => console.error('MongoDB connection error:', err));
// Initialize LiveOrderMonitor
LiveOrderMonitor.getInstance().start();
// Routes
app.use('/api', apiRoutes);
// Start server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
// Graceful shutdown
const gracefulShutdown = async () => {
  console.log('Shutting down gracefully...');
  // Stop LiveOrderMonitor
  LiveOrderMonitor.getInstance().stop();
  // Cleanup WebSocketManager
  WebSocketManager.getInstance().cleanup();
  // Close server
  server.close(() => {
    console.log('Server closed');
    // Close MongoDB connection
    mongoose.connection.close().then(() => {
      console.log('MongoDB connection closed');
      process.exit(0);
    });
  });
  // Force close if it takes too long
  setTimeout(() => {
    console.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
};
// Listen for termination signals
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);
export { app, server };
</file>

<file path="utils/rabbitmq.ts">
import amqp from 'amqplib';
class RabbitMQService {
  private static instance: RabbitMQService;
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;
  private constructor() {}
  static getInstance(): RabbitMQService {
    if (!RabbitMQService.instance) {
      RabbitMQService.instance = new RabbitMQService();
    }
    return RabbitMQService.instance;
  }
  async connect(): Promise<void> {
    try {
      this.connection = await amqp.connect(process.env.RABBITMQ_URL || 'amqp://localhost');
      this.channel = await this.connection.createChannel();
      // Define queues
      await this.channel.assertQueue('order_created', { durable: true });
      await this.channel.assertQueue('order_updated', { durable: true });
      await this.channel.assertQueue('payment_processed', { durable: true });
      await this.channel.assertQueue('notification', { durable: true });
      console.log('Connected to RabbitMQ');
    } catch (error) {
      console.error('RabbitMQ connection error:', error);
      throw error;
    }
  }
  async publishMessage(queue: string, message: any): Promise<void> {
    if (!this.channel) {
      throw new Error('Channel not established');
    }
    try {
      this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)));
    } catch (error) {
      console.error('Error publishing message:', error);
      throw error;
    }
  }
  async consumeMessage(queue: string, callback: (message: any) => void): Promise<void> {
    if (!this.channel) {
      throw new Error('Channel not established');
    }
    try {
      await this.channel.consume(queue, (message) => {
        if (message) {
          const content = JSON.parse(message.content.toString());
          callback(content);
          this.channel?.ack(message);
        }
      });
    } catch (error) {
      console.error('Error consuming message:', error);
      throw error;
    }
  }
  async closeConnection(): Promise<void> {
    try {
      if (this.channel) {
        await this.channel.close();
      }
      if (this.connection) {
        await this.connection.close();
      }
    } catch (error) {
      console.error('Error closing RabbitMQ connection:', error);
      throw error;
    }
  }
}
export default RabbitMQService;
</file>

<file path=".gitignore">
node_modules
.env
</file>

<file path="nodemon.json">
{
  "watch": ["src", "services"],
  "ext": ".ts,.js",
  "ignore": [],
  "exec": "ts-node ./src/app.ts"
}
</file>

<file path="package.json">
{
  "name": "inseat-backend",
  "version": "1.0.0",
  "description": "Restaurant Management System Backend Services",
  "scripts": {
    "build": "tsc",
    "start": "node dist/src/app.js",
    "dev": "nodemon",
    "dev:watch": "ts-node-dev --respawn --transpile-only src/app.ts",
    "test": "jest",
    "typecheck": "tsc --noEmit",
    "lint": "eslint . --ext .ts"
  },
  "dependencies": {
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^10.0.0",
    "amqplib": "^0.10.3",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.21.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^7.8.6",
    "qrcode": "^1.5.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "socket.io": "^4.7.2",
    "stripe": "^14.1.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "typescript": "^5.2.2",
    "uuid": "^11.1.0",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@prisma/client": "^6.5.0",
    "@types/amqplib": "^0.10.6",
    "@types/bcrypt": "^5.0.2",
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/mongoose": "^5.11.96",
    "@types/node": "^22.13.10",
    "@types/qrcode": "^1.5.5",
    "@types/socket.io": "^3.0.1",
    "@types/supertest": "^6.0.2",
    "@types/ws": "^8.18.0",
    "cursor-tools": "latest",
    "eslint": "^8.30.0",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "supertest": "^6.3.3",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2018",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "noImplicitAny": false,
    "strictFunctionTypes": false,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@services/*": ["services/*"],
      "@utils/*": ["utils/*"]
    }
  },
  "include": ["src/**/*", "services/**/*", "utils/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

</files>
