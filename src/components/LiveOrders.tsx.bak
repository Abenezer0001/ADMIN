import React from 'react';
import { Spin, Table, Tag, Input, Button, Typography, Badge, Space, message, notification, Drawer, Descriptions, List, Avatar, Divider, Empty, Select } from 'antd';
import { SearchOutlined, ReloadOutlined, BellOutlined, InfoCircleOutlined, CheckCircleOutlined, ClockCircleOutlined } from '@ant-design/icons';
import OrderService from '../services/OrderService';
import WebSocketService, { WebSocketEventType } from '../services/websocketService';
import { Order, OrderStatus } from '../types/order';
import { restaurantService, Restaurant } from '../services/RestaurantService';
import type { ColumnsType } from 'antd/es/table';

const { Search } = Input;
const { Title, Text } = Typography;

// Define interface for any extra fields that might be present on orders from the backend but not in our types
interface OrderWithMeta extends Order {
  tableNumber?: string;
  customerName?: string;
}

const LiveOrders: React.FC = () => {
  const [orders, setOrders] = React.useState<OrderWithMeta[]>([]);
  const [loading, setLoading] = React.useState<boolean>(true);
  const [searchQuery, setSearchQuery] = React.useState<string>('');
  const [selectedOrder, setSelectedOrder] = React.useState<OrderWithMeta | null>(null);
  const [orderDetailsVisible, setOrderDetailsVisible] = React.useState<boolean>(false);
  const [newOrdersCount, setNewOrdersCount] = React.useState<number>(0);
  
  // Restaurant selection state
  const [restaurants, setRestaurants] = React.useState<Restaurant[]>([]);
  const [selectedRestaurantId, setSelectedRestaurantId] = React.useState<string>('');
  const [loadingRestaurants, setLoadingRestaurants] = React.useState<boolean>(false);
  const [wsConnected, setWsConnected] = React.useState<boolean>(false);

  // Format currency helper function
  const formatCurrency = (amount: number): string => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
    }).format(amount);
  };

  // Format date helper function
  const formatDate = (dateString: string | null): string => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleString();
  };

  // Fetch restaurants when component mounts
  React.useEffect(() => {
    const fetchRestaurants = async () => {
      try {
        setLoadingRestaurants(true);
        const data = await restaurantService.getRestaurants();
        
        // Ensure data is treated as a Restaurant array
        const restaurantData: Restaurant[] = Array.isArray(data) ? data : [];
        setRestaurants(restaurantData);

        // If we have restaurants, select the first one by default
        if (restaurantData.length > 0) {
          // Check if there's a saved restaurant ID in localStorage
          const savedRestaurantId = localStorage.getItem('currentRestaurantId');
          if (savedRestaurantId && restaurantData.some((r: Restaurant) => r._id === savedRestaurantId)) {
            setSelectedRestaurantId(savedRestaurantId);
          } else {
            setSelectedRestaurantId(restaurantData[0]._id);
            localStorage.setItem('currentRestaurantId', restaurantData[0]._id);
          }
        }
      } catch (err) {
        console.error('Error fetching restaurants:', err);
        message.error('Failed to fetch restaurants. Please refresh the page.');
      } finally {
        setLoadingRestaurants(false);
      }
    };

    fetchRestaurants();
  }, []);

  // Connect to WebSocket when selected restaurant changes
  React.useEffect(() => {
    if (!selectedRestaurantId) return;
    
    setLoading(true);
    setOrders([]);  // Clear orders when restaurant changes
    
    try {
      console.log(`Connecting to WebSocket for restaurant: ${selectedRestaurantId}`);
      // Save selected restaurant ID to localStorage
      localStorage.setItem('currentRestaurantId', selectedRestaurantId);
      
      // Initialize WebSocket connection for this restaurant
      WebSocketService.disconnect();  // Disconnect any existing connection first
      WebSocketService.connect(selectedRestaurantId);
      
      // Listen for connection events
      WebSocketService.addEventListener(WebSocketEventType.CONNECT, () => {
        console.log('WebSocket connected successfully');
        setWsConnected(true);
        message.success('Connected to live order updates');
      });
      
      WebSocketService.addEventListener(WebSocketEventType.DISCONNECT, () => {
        console.log('WebSocket disconnected');
        setWsConnected(false);
        message.warning('Lost connection to live order updates');
      });
      
      // Initialize order service context
      OrderService.setRestaurantContext(selectedRestaurantId);
      
      // Fetch initial orders
      fetchOrders();
      
      // Set up WebSocket event listeners
      setupWebSocketListeners();

      // Set up connection status check at regular intervals
      const connectionCheckInterval = setInterval(() => {
        if (!WebSocketService.isConnected()) {
          console.log('WebSocket disconnected, attempting to reconnect...');
          WebSocketService.connect(selectedRestaurantId);
        }
      }, 30000); // Every 30 seconds
      
      // Clean up WebSocket listeners and interval when component unmounts or restaurant changes
      return () => {
        try {
          console.log('Cleaning up WebSocket connection and intervals');
          clearInterval(connectionCheckInterval);
          WebSocketService.removeAllEventListeners();
          WebSocketService.disconnect();
        } catch (error) {
          console.error('Error cleaning up resources:', error);
        }
      };
    } catch (error) {
      console.error('Error initializing WebSocket:', error);
      message.error('Failed to connect to real-time order updates. Please refresh the page.');
      setLoading(false);
    }
  }, [selectedRestaurantId]);  // Re-run this effect when the selected restaurant changes
  
  // Set up WebSocket event listeners
  const setupWebSocketListeners = () => {
    try {
      console.log('Setting up WebSocket event listeners');
      
      // Listen for new orders
      OrderService.onNewOrder((order: OrderWithMeta) => {
        console.log('New order received in LiveOrders component:', order);
        // Ensure order has all necessary fields
        if (!order || !order._id) {
          console.error('Received invalid order data:', order);
          return;
        }
        
        setOrders((prevOrders: OrderWithMeta[]) => {
          // Check if order already exists
          const exists = prevOrders.some(existingOrder => existingOrder._id === order._id);
          if (exists) {
            return prevOrders;
          }
          return [order, ...prevOrders];
        });
        
        setNewOrdersCount((prev: number) => prev + 1);
        notification.info({
          message: 'New Order Received',
          description: `Order #${order.orderNumber || 'New'} has been received.`,
          placement: 'topRight'
        });
      });
      
      // Listen for order updates
      OrderService.onOrderUpdated((updatedOrder: OrderWithMeta) => {
        console.log('Order update received in LiveOrders component:', updatedOrder);
        if (!updatedOrder || !updatedOrder._id) {
          console.error('Received invalid order update data:', updatedOrder);
          return;
        }
        
        setOrders((prevOrders: OrderWithMeta[]) => prevOrders.map((order: OrderWithMeta) => 
          order._id === updatedOrder._id ? updatedOrder : order
        ));
        
        // If this order is currently selected, update it
        if (selectedOrder && selectedOrder._id === updatedOrder._id) {
          setSelectedOrder(updatedOrder);
        }
      });
      
      // Listen for order cancellations
      OrderService.onOrderCancelled((cancelledOrder: OrderWithMeta) => {
        console.log('Order cancellation received in LiveOrders component:', cancelledOrder);
        if (!cancelledOrder || !cancelledOrder._id) {
          console.error('Received invalid order cancellation data:', cancelledOrder);
          return;
        }
        
        setOrders((prevOrders: OrderWithMeta[]) => prevOrders.map((order: OrderWithMeta) => 
          order._id === cancelledOrder._id ? cancelledOrder : order
        ));
        
        notification.warning({
          message: 'Order Cancelled',
          description: `Order #${cancelledOrder.orderNumber || 'Unknown'} has been cancelled.`,
          placement: 'topRight'
        });
        
        // If this order is currently selected, update it
        if (selectedOrder && selectedOrder._id === cancelledOrder._id) {
          setSelectedOrder(cancelledOrder);
        }
      });
    } catch (error) {
      console.error('Error setting up WebSocket listeners:', error);
      message.error('Failed to setup real-time order notifications.');
    }
  };
  
  // Reset new orders counter
  const resetNewOrdersCount = () => {
    setNewOrdersCount(0);
  };

  // Fetch orders from API
  const fetchOrders = async () => {
    if (!selectedRestaurantId) {
      setOrders([]);
      setLoading(false);
      return;
    }
    
    setLoading(true);
    try {
      console.log(`Fetching active orders for restaurant: ${selectedRestaurantId}`);
      const response = await OrderService.getAllOrders({
        restaurantId: selectedRestaurantId,
        status: [
          OrderStatus.PENDING,
          OrderStatus.PREPARING,
          OrderStatus.READY
        ].join(',') // Only active orders
      });
      
      if (response && response.data) {
        console.log(`Fetched ${response.data.length} active orders`);
        setOrders(response.data as OrderWithMeta[]);
        resetNewOrdersCount(); // Reset counter after fetching
      } else {
        console.warn('No orders data returned from API');
        setOrders([]);
      }
      
      // Ensure WebSocket connection is active after fetching orders
      if (selectedRestaurantId && !WebSocketService.isConnected()) {
        console.log('WebSocket not connected, reconnecting...');
        WebSocketService.connect(selectedRestaurantId);
      }
    } catch (error) {
      console.error('Error fetching orders:', error);
      message.error('Failed to load orders. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Handle search input change
  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  // Filter orders based on search query
  const filteredOrders = orders.filter((order: OrderWithMeta) => 
    (order.orderNumber && order.orderNumber.toString().toLowerCase().includes(searchQuery.toLowerCase())) ||
    (order.customerName && order.customerName.toString().toLowerCase().includes(searchQuery.toLowerCase())) ||
    (order.tableNumber && order.tableNumber.toString().toLowerCase().includes(searchQuery.toLowerCase()))
  );

  // Open order details drawer
  const showOrderDetails = (order: OrderWithMeta) => {
    setSelectedOrder(order);
    setOrderDetailsVisible(true);
  };

  // Close order details drawer
  const closeOrderDetails = () => {
    setSelectedOrder(null);
    setOrderDetailsVisible(false);
  };

  // Update order status
  const updateOrderStatus = async (orderId: string, status: OrderStatus) => {
    try {
      await OrderService.updateOrderStatus(orderId, status);
      
      // Update local state
      setOrders((prevOrders: OrderWithMeta[]) => prevOrders.map((order: OrderWithMeta) => 
        order._id === orderId ? { ...order, status } : order
      ));
      
      // Close drawer if open with this order
      if (selectedOrder && selectedOrder._id === orderId) {
        setSelectedOrder((prev: OrderWithMeta | null) => prev ? { ...prev, status } : null);
      }
      
      notification.success({ 
        message: `Order status updated to ${getStatusDisplayName(status)}` 
      });
    } catch (error) {
      console.error('Error updating order status:', error);
      message.error('Failed to update order status. Please try again.');
    }
  };

  // Get next status based on current status
  const getNextStatus = (currentStatus: string): OrderStatus => {
    switch (currentStatus) {
      case OrderStatus.PENDING:
        return OrderStatus.PREPARING;
      case OrderStatus.PREPARING:
        return OrderStatus.READY;
      case OrderStatus.READY:
        return OrderStatus.DELIVERED;
      case OrderStatus.DELIVERED:
        return OrderStatus.COMPLETED;
      default:
        return OrderStatus.PREPARING;
    }
  };

  // Get status display name
  const getStatusDisplayName = (status: string): string => {
    switch (status) {
      case OrderStatus.PENDING:
        return 'Pending';
      case OrderStatus.PREPARING:
        return 'Preparing';
      case OrderStatus.READY:
        return 'Ready';
      case OrderStatus.DELIVERED:
        return 'Delivered';
      case OrderStatus.COMPLETED:
        return 'Completed';
      case OrderStatus.CANCELLED:
        return 'Cancelled';
      default:
        return 'Unknown';
    }
  };

  // Get status tag color
  const getStatusTagColor = (status: string): string => {
    switch (status) {
      case OrderStatus.PENDING:
        return 'warning';
      case OrderStatus.PREPARING:
        return 'processing';
      case OrderStatus.READY:
        return 'success';
      case OrderStatus.DELIVERED:
        return 'success';
      case OrderStatus.COMPLETED:
        return 'success';
      case OrderStatus.CANCELLED:
        return 'error';
      default:
        return 'default';
    }
  };

  // Get action buttons for order based on current status
  const renderOrderActions = (order: OrderWithMeta) => {
    const nextStatus = getNextStatus(order.status as string);
    
    return (
      <Space>
        <Button 
          type="primary" 
          size="small" 
          onClick={() => showOrderDetails(order)}
          icon={<InfoCircleOutlined />}
        >
          Details
        </Button>
        {order.status === OrderStatus.PENDING && (
          <Button 
            type="primary" 
            size="small" 
            onClick={() => updateOrderStatus(order._id, OrderStatus.PREPARING)}
          >
            Accept
          </Button>
        )}
        {order.status === OrderStatus.PREPARING && (
          <Button 
            type="primary" 
            size="small" 
            onClick={() => updateOrderStatus(order._id, OrderStatus.READY)}
          >
            Mark Ready
          </Button>
        )}
        {order.status === OrderStatus.READY && (
          <Button 
            type="primary" 
            size="small" 
            onClick={() => updateOrderStatus(order._id, OrderStatus.DELIVERED)}
          >
            Complete
          </Button>
        )}
      </Space>
    );
  };

  // Table columns definition
  const columns: ColumnsType<OrderWithMeta> = [
    {
      title: 'Order #',
      dataIndex: 'orderNumber',
      key: 'orderNumber',
      render: (text: string, record: OrderWithMeta) => (
        <Button type="link" onClick={() => showOrderDetails(record)}>
          {text}
        </Button>
      )
    },
    {
      title: 'Table',
      dataIndex: 'tableNumber',
      key: 'tableNumber',
    },
    {
      title: 'Customer',
      dataIndex: 'customerName',
      key: 'customerName',
    },
    {
      title: 'Items',
      key: 'items',
      render: (_, record: OrderWithMeta) => (
        <span>{record.items?.length || 0} items</span>
      ),
    },
    {
      title: 'Total',
      dataIndex: 'total',
      key: 'total',
      render: (amount: number) => formatCurrency(amount)
    },
    {
      title: 'Time',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (text: string) => formatDate(text)
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (status: string) => {
        let color = 'default';
        let icon = null;
        
        switch(status) {
          case OrderStatus.PENDING:
            color = 'warning';
            icon = <ClockCircleOutlined />;
            break;
          case OrderStatus.PREPARING:
            color = 'processing';
            icon = <ClockCircleOutlined />;
            break;
          case OrderStatus.READY:
            color = 'success';
            icon = <CheckCircleOutlined />;
            break;
          case OrderStatus.CANCELLED:
            color = 'error';
            break;
          default:
            color = 'default';
        }
        
        return <Tag icon={icon} color={color}>{getStatusDisplayName(status)}</Tag>;
      }
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_, record: OrderWithMeta) => renderOrderActions(record)
    },
  ];

              />
            </div>
          ),
        }}
      />
    )}
      
    {/* Order Details Drawer */}
    <Drawer
      title={selectedOrder ? `Order #${selectedOrder.orderNumber} Details` : 'Order Details'}
      placement="right"
      onClose={closeOrderDetails}
      open={orderDetailsVisible}
      width={500}
      extra={
        selectedOrder && selectedOrder.status !== OrderStatus.COMPLETED && selectedOrder.status !== OrderStatus.CANCELLED ? (
          <Space>
            <Button 
              type="primary"
              onClick={() => {
                if (selectedOrder) {
                  updateOrderStatus(selectedOrder._id, getNextStatus(selectedOrder.status as string));
                }
              }}
            >
              {selectedOrder?.status === OrderStatus.PENDING ? 'Confirm' : 
               selectedOrder?.status === OrderStatus.PREPARING ? 'Mark Ready' :
               selectedOrder?.status === OrderStatus.READY ? 'Mark Delivered' :
               selectedOrder?.status === OrderStatus.DELIVERED ? 'Complete' : 'Update'}
            </Button>
            <Button 
              danger
              onClick={() => {
                if (selectedOrder) {
                  updateOrderStatus(selectedOrder._id, OrderStatus.CANCELLED);
                }
              }}
            >
              Cancel Order
            </Button>
          </Space>
        ) : null
      }
    >
      {selectedOrder && (
        <>
          <Descriptions column={1} bordered>
            <Descriptions.Item label="Status">
              <Tag color={getStatusTagColor(selectedOrder.status as string)}>
                {getStatusDisplayName(selectedOrder.status as string)}
              </Tag>
            </Descriptions.Item>
            {selectedOrder.customerName && (
              <Descriptions.Item label="Customer">
                {selectedOrder.customerName}
              </Descriptions.Item>
            )}
            {selectedOrder.tableNumber && (
              <Descriptions.Item label="Table">
                {selectedOrder.tableNumber}
              </Descriptions.Item>
            )}
            <Descriptions.Item label="Order Time">
              {formatDate(selectedOrder.createdAt as string)}
            </Descriptions.Item>
            <Descriptions.Item label="Total">
              {formatCurrency(selectedOrder.total || 0)}
            </Descriptions.Item>
            {selectedOrder.notes && (
              <Descriptions.Item label="Notes">
                {selectedOrder.notes}
              </Descriptions.Item>
            )}
          </Descriptions>
            
          <Divider orientation="left">Order Items</Divider>
            
          <List
            itemLayout="horizontal"
            dataSource={selectedOrder.items || []}
            renderItem={(item: any) => (
              <List.Item>
                <List.Item.Meta
                  avatar={<Avatar>{item.quantity}</Avatar>}
          description={
            searchQuery 
              ? "No orders matching your search" 
              : "No active orders at the moment"
          }
          image={Empty.PRESENTED_IMAGE_SIMPLE}
        />
      ) : (
        <Table 
          columns={columns} 
          dataSource={filteredOrders}
          rowKey="_id"
          pagination={false}
          expandable={{
            expandedRowRender: (record: OrderWithMeta) => (
              <div style={{ padding: '0 20px' }}>
                <strong>Order Items:</strong>
                <List
                  itemLayout="horizontal"
                  dataSource={record.items || []}
                  renderItem={(item: any) => (
                    <List.Item>
                      <List.Item.Meta
                        title={`${item.quantity}x ${item.name}`}
                        description={item.notes ? `Note: ${item.notes}` : null}
                      />
                      <div>{formatCurrency(item.price * item.quantity)}</div>
                    </List.Item>
                  )}
                />
              </div>
            ),
          }}
        />
      )}
      
      {/* Order Details Drawer */}
      <Drawer
        title={selectedOrder ? `Order #${selectedOrder.orderNumber} Details` : 'Order Details'}
        placement="right"
        onClose={closeOrderDetails}
        open={orderDetailsVisible}
        width={500}
        extra={
          selectedOrder && selectedOrder.status !== OrderStatus.COMPLETED && selectedOrder.status !== OrderStatus.CANCELLED ? (
            <Space>
              <Button 
                type="primary"
                onClick={() => {
                  if (selectedOrder) {
                    updateOrderStatus(selectedOrder._id, getNextStatus(selectedOrder.status as string));
                  }
                }}
              >
                {selectedOrder?.status === OrderStatus.PENDING ? 'Confirm' : 
                 selectedOrder?.status === OrderStatus.PREPARING ? 'Mark Ready' :
                 selectedOrder?.status === OrderStatus.READY ? 'Mark Delivered' :
                 selectedOrder?.status === OrderStatus.DELIVERED ? 'Complete' : 'Update'}
              </Button>
              <Button 
                danger
                onClick={() => {
                  if (selectedOrder) {
                    updateOrderStatus(selectedOrder._id, OrderStatus.CANCELLED);
                  }
                }}
              >
                Cancel Order
              </Button>
            </Space>
          ) : null
        }
      >
        {selectedOrder && (
          <>
            <Descriptions column={1} bordered>
              <Descriptions.Item label="Status">
                <Tag color={getStatusTagColor(selectedOrder.status as string)}>
                  {getStatusDisplayName(selectedOrder.status as string)}
                </Tag>
              </Descriptions.Item>
              {selectedOrder.customerName && (
                <Descriptions.Item label="Customer">
                  {selectedOrder.customerName}
                </Descriptions.Item>
              )}
              {selectedOrder.tableNumber && (
                <Descriptions.Item label="Table">
                  {selectedOrder.tableNumber}
                </Descriptions.Item>
              )}
              <Descriptions.Item label="Order Time">
                {formatDate(selectedOrder.createdAt as string)}
              </Descriptions.Item>
              <Descriptions.Item label="Total">
                {formatCurrency(selectedOrder.total || 0)}
              </Descriptions.Item>
              {selectedOrder.notes && (
                <Descriptions.Item label="Notes">
                  {selectedOrder.notes}
                </Descriptions.Item>
              )}
            </Descriptions>
            
            <Divider orientation="left">Order Items</Divider>
            
            <List
              itemLayout="horizontal"
              dataSource={selectedOrder.items || []}
              renderItem={(item: any) => (
                <List.Item>
                  <List.Item.Meta
                    avatar={<Avatar>{item.quantity}</Avatar>}
                    title={item.name}
                    description={
                      <>
                        {item.notes && <div>Note: {item.notes}</div>}
                        {item.modifiers && item.modifiers.length > 0 && (
                          <div>
                            <Text type="secondary">Modifiers:</Text>
                            <ul style={{ paddingLeft: '20px', margin: '4px 0' }}>
                              {item.modifiers.map((mod: any, index: number) => (
                                <li key={index}>
                                  <Text>{mod.name}: </Text>
                                  {mod.selections.map((sel: any, idx: number) => (
                                    <Tag key={idx}>
                                      {sel.quantity}x {sel.name} ({formatCurrency(sel.price)})
                                    </Tag>
                                  ))}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}
                      </>
                    }
                  />
                  <div>
                    <div style={{ textAlign: 'right' }}>
                      <Text type="secondary">{formatCurrency(item.price)} each</Text>
                    </div>
                    <div>
                      <Text strong>{formatCurrency(item.price * item.quantity)}</Text>
                    </div>
                  </div>
                </List.Item>
              )}
            />
            
            <Divider />
            
            <div style={{ textAlign: 'right' }}>
              <Text style={{ marginRight: '8px' }}>Subtotal:</Text>
              <Text strong>{formatCurrency(selectedOrder.subtotal || 0)}</Text>
            </div>
            {selectedOrder.tax !== undefined && (
              <div style={{ textAlign: 'right', margin: '8px 0' }}>
                <Text style={{ marginRight: '8px' }}>Tax:</Text>
                <Text strong>{formatCurrency(selectedOrder.tax)}</Text>
              </div>
            )}
            {selectedOrder.tip !== undefined && (
              <div style={{ textAlign: 'right', margin: '8px 0' }}>
                <Text style={{ marginRight: '8px' }}>Tip:</Text>
                <Text strong>{formatCurrency(selectedOrder.tip)}</Text>
              </div>
            )}
            <div style={{ textAlign: 'right', margin: '16px 0 0' }}>
              <Text style={{ marginRight: '8px' }} strong>Total:</Text>
              <Text strong style={{ fontSize: '18px' }}>{formatCurrency(selectedOrder.total || 0)}</Text>
            </div>
          </>
        )}
      </Drawer>
    </div>
  );
};

export default LiveOrders;
